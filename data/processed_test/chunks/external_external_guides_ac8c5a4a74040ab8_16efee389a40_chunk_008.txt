Since the match() method only checks if the RE matches at the start of a string, start() will always be zero. However, the search() method of patterns scans through the string, so the match may not start at zero in that case. group() start() end() span() match() start() search() >>> print(p. match('::: message')) None >>> m = p. search('::: message'); print(m) <re. Match object; span=(4, 11), match='message'> >>> m. group() 'message' >>> m. span() (4, 11) In actual programs, the most common style is to store the match object in a variable, and then check if it was None. This usually looks like: None p = re. compile(. ) m = p. match( 'string goes here' ) if m: print('Match found: ', m. group()) else: print('No match') Two pattern methods return all of the matches for a pattern. findall() returns a list of matching strings: findall() >>> p = re. compile(r'\d+') >>> p. findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping') ['12', '11', '10'] The r prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a DeprecationWarning and will eventually become a SyntaxError. See The Backslash Plague. r DeprecationWarning SyntaxError findall() has to create the entire list before it can be returned as the result. The finditer() method returns a sequence of match object instances as an iterator: findall() finditer() >>> iterator = p. finditer('12 drummers drumming, 11. 10. ') >>> iterator <callable_iterator object at 0x. > >>> for match in iterator:. print(match. span()). (0, 2) (22, 24) (29, 31) ### Module-Level Functions¶ You don’t have to create a pattern object and call its methods; the re module also provides top-level functions called match(), search(), findall(), sub(), and so forth.