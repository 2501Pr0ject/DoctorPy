match("717ak")) # Pair of 7s. "<Match: '717', groups=('7',)>" >>> displaymatch(pair. match("718ak")) # No pairs. >>> displaymatch(pair. match("354aa")) # Pair of aces. "<Match: '354aa', groups=('a',)>" To find out what card the pair consists of, one could use the group() method of the match object in the following manner: group() >>> pair = re. compile(r". *(. ). *\1") >>> pair. match("717ak"). group(1) '7' # Error because re. match() returns None, which doesn't have a group() method: >>> pair. match("718ak"). group(1) Traceback (most recent call last): File "<pyshell#23>", line 1, in <module> re. match(r". *(. ). *\1", "718ak"). group(1) AttributeError: 'NoneType' object has no attribute 'group' >>> pair. match("354aa"). group(1) 'a' ### Simulating scanf()Â¶ Python does not currently have an equivalent to scanf(). Regular expressions are generally more powerful, though also more verbose, than scanf() format strings. The table below offers some more-or-less equivalent mappings between scanf() format tokens and regular expressions. scanf() scanf() scanf() scanf() Token scanf() Regular Expression %c %c. %5c %5c. {5}. {5} %d %d [-+]. \d+ [-+]. \d+ %e, %E, %f, %g %e %E %f %g [-+]. (\d+(. \d). |. \d+)([eE][-+]. \d+). [-+]. (\d+(\. \d*). |\. \d+)([eE][-+]. \d+). %i %i [-+]. (0[xX][\dA-Fa-f]+|0[0-7]*|\d+) [-+]. (0[xX][\dA-Fa-f]+|0[0-7]*|\d+) %o %o [-+]. [0-7]+ [-+].