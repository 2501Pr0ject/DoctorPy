The value of the start parameter (or 0 if the parameter was not supplied) 0 The value of the stop parameter The value of the step parameter (or 1 if the parameter was not supplied) 1 The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). range list tuple range start stop step Range objects implement the collections. abc. Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): collections. abc. Sequence >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r. index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and. = compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2). ) ==. = start stop step range(0) == range(2, 1, 3) range(0, 3, 2) == range(0, 4, 2) Changed in version 3. 2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. int Changed in version 3. 3: Define ‘==’ and ‘. =’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). Added the start, stop and step attributes. start stop step See also The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications. The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications.