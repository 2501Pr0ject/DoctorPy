walk('python/Lib/xml'): print(root, "consumes", end=" ") print(sum(getsize(join(root, name)) for name in files), end=" ") print("bytes in", len(files), "non-directory files") if '__pycache__' in dirs: dirs. remove('__pycache__') # don't visit __pycache__ directories In the next example (simple implementation of shutil. rmtree()), walking the tree bottom-up is essential, rmdir() doesnâ€™t allow deleting a directory before the directory is empty: shutil. rmtree() rmdir() # Delete everything reachable from the directory named in "top", # assuming there are no symbolic links. # CAUTION: This is dangerous. For example, if top == '/', it # could delete all your disk files. import os for root, dirs, files in os. walk(top, topdown=False): for name in files: os. remove(os. path. join(root, name)) for name in dirs: os. rmdir(os. path. join(root, name)) os. rmdir(top) Raises an auditing event os. walk with arguments top, topdown, onerror, followlinks. os. walk top topdown onerror followlinks Changed in version 3. 5: This function now calls os. scandir() instead of os. listdir(), making it faster by reducing the number of calls to os. stat(). os. scandir() os. listdir() os. stat() Changed in version 3. 6: Accepts a path-like object. This behaves exactly like walk(), except that it yields a 4-tuple (dirpath, dirnames, filenames, dirfd), and it supports dir_fd. walk() (dirpath, dirnames, filenames, dirfd) dir_fd dirpath, dirnames and filenames are identical to walk() output, and dirfd is a file descriptor referring to the directory dirpath. walk() This function always supports paths relative to directory descriptors and not following symlinks. Note however that, unlike other functions, the fwalk() default value for follow_symlinks is False. fwalk() False Note Since fwalk() yields file descriptors, those are only valid until the next iteration step, so you should duplicate them (e. g. with dup()) if you want to keep them longer.