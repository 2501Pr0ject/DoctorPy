def _(arg: int, verbose=False):. if verbose:. print("Strength in numbers, eh. ", end=" "). print(arg). >>> @fun. register. def _(arg: list, verbose=False):. if verbose:. print("Enumerate this:"). for i, elem in enumerate(arg):. print(i, elem) types. UnionType and typing. Union can also be used: types. UnionType typing. Union >>> @fun. register. def _(arg: int | float, verbose=False):. if verbose:. print("Strength in numbers, eh. ", end=" "). print(arg). >>> from typing import Union >>> @fun. register. def _(arg: Union[list, set], verbose=False):. if verbose:. print("Enumerate this:"). for i, elem in enumerate(arg):. print(i, elem). For code which doesnâ€™t use type annotations, the appropriate type argument can be passed explicitly to the decorator itself: >>> @fun. register(complex). def _(arg, verbose=False):. if verbose:. print("Better than complicated. ", end=" "). print(arg. real, arg. imag). For code that dispatches on a collections type (e. g. , list), but wants to typehint the items of the collection (e. g. , list[int]), the dispatch type should be passed explicitly to the decorator itself with the typehint going into the function definition: list list[int] >>> @fun. register(list). def _(arg: list[int], verbose=False):. if verbose:. print("Enumerate this:"). for i, elem in enumerate(arg):. print(i, elem) Note At runtime the function will dispatch on an instance of a list regardless of the type contained within the list i. e. [1,2,3] will be dispatched the same as ["foo", "bar", "baz"]. The annotation provided in this example is for static type checkers only and has no runtime impact. [1,2,3] ["foo", "bar", "baz"] To enable registering lambdas and pre-existing functions, the register() attribute can also be used in a functional form: register() >>> def nothing(arg, verbose=False):. print("Nothing. "). >>> fun. register(type(None), nothing) The register() attribute returns the undecorated function.