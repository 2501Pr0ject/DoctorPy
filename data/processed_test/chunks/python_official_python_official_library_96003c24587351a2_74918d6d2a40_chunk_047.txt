cmp_to_key() sorted() < __lt__() max() __gt__() class C: @staticmethod def f(arg1, arg2, argN):. @staticmethod C. f() C(). f() f() classmethod() staticmethod def regular_function():. class C: method = staticmethod(regular_function) __module__ __name__ __qualname__ __doc__ __annotations__ __wrapped__ str str() str sum() ''. join(sequence) math. fsum() itertools. chain() __mro__ D -> B -> C -> A -> object B super() C -> A -> object __mro__ getattr() super() isinstance(obj, type) issubclass(type2, type) super() self super() class C(B): def method(self, arg): super(). method(arg) # This does the same thing as: # super(C, self). method(arg) super() super() super(). __getitem__(name) __getattribute__() super() super()[name] super() super() tuple object. __class__ isinstance() class __name__ __bases__ object __dict__ type >>> class X:. a = 1. >>> X = type('X', (), dict(a=1)) __init_subclass__() type type. __new__ __dict__ __dict__ __dict__ __dict__ types. MappingProxyType vars() locals() TypeError __dict__ __slots__ locals() >>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):. print(item). (1, 'sugar') (2, 'spice') (3, 'everything nice') zip() zip() zip() for list zip() zip() >>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum'])) [(0, 'fee'), (1, 'fi'), (2, 'fo')] zip() strict=True zip() >>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True)) [('a', 1), ('b', 2), ('c', 3)] ValueError >>> for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):. print(item). (0, 'fee') (1, 'fi') (2, 'fo') Traceback (most recent call last):.