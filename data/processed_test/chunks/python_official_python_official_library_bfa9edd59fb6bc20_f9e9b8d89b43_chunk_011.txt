If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys. hash_info. inf. x = m / n n P m n P hash(x) sys. hash_info. inf If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. x = m / n hash(x) -hash(-x) -1 -2 The particular values sys. hash_info. inf and -sys. hash_info. inf are used as hash values for positive infinity or negative infinity (respectively). The particular values sys. hash_info. inf and -sys. hash_info. inf are used as hash values for positive infinity or negative infinity (respectively). sys. hash_info. inf -sys. hash_info. inf For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z. real) + sys. hash_info. imag * hash(z. imag), reduced modulo 2sys. hash_info. width so that it lies in range(-2(sys. hash_info. width - 1), 2(sys. hash_info. width - 1)). Again, if the result is -1, it’s replaced with -2. For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z. real) + sys. hash_info. imag * hash(z. imag), reduced modulo 2sys. hash_info. width so that it lies in range(-2(sys. hash_info. width - 1), 2(sys. hash_info. width - 1)). Again, if the result is -1, it’s replaced with -2. complex z hash(z. real) + sys. hash_info. imag * hash(z. imag) 2**sys. hash_info. width range(-2**(sys. hash_info. width - 1), 2**(sys. hash_info.