You can call the next() method using the next() built-in function; this example shows how it all works: for iter() __next__() __next__() StopIteration for __next__() next() >>> s = 'abc' >>> it = iter(s) >>> it <str_iterator object at 0x10c90e650> >>> next(it) 'a' >>> next(it) 'b' >>> next(it) 'c' >>> next(it) Traceback (most recent call last): File "<stdin>", line 1, in <module> next(it) StopIteration Having seen the mechanics behind the iterator protocol, it is easy to add iterator behavior to your classes. Define an iter() method which returns an object with a next() method. If the class defines next(), then iter() can just return self: __iter__() __next__() __next__() __iter__() self class Reverse: """Iterator for looping over a sequence backwards. """ def __init__(self, data): self. data = data self. index = len(data) def __iter__(self): return self def __next__(self): if self. index == 0: raise StopIteration self. index = self. index - 1 return self. data[self. index] >>> rev = Reverse('spam') >>> iter(rev) <__main__. Reverse object at 0x00A1DB50> >>> for char in rev:. print(char). m a p s ## 9. 9. GeneratorsÂ¶ Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create: yield next() def reverse(data): for index in range(len(data)-1, -1, -1): yield data[index] >>> for char in reverse('golf'):. print(char). f l o g Anything that can be done with generators can also be done with class-based iterators as described in the previous section. What makes generators so compact is that the iter() and next() methods are created automatically. __iter__() __next__() Another key feature is that the local variables and execution state are automatically saved between calls.