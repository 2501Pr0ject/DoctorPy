{
  "chunk_id": "python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30_chunk_028",
  "original_doc_id": "python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30",
  "content": "TypeVar The annotations of generic functions are evaluated within the annotation scope used for declaring the type parameters, but the function’s defaults and decorators are not. The following example illustrates the scoping rules for these cases, as well as for additional flavors of type parameters: @decorator def funcT: int, *Ts, **P:. Except for the lazy evaluation of the TypeVar bound, this is equivalent to: TypeVar DEFAULT_OF_arg = some_default annotation-def TYPE_PARAMS_OF_func(): annotation-def BOUND_OF_T(): return int # In reality, BOUND_OF_T() is evaluated only on demand. T = typing. TypeVar(\"T\", bound=BOUND_OF_T()) Ts = typing. TypeVarTuple(\"Ts\") P = typing. ParamSpec(\"P\") def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):. func. __type_params__ = (T, Ts, P) return func func = decorator(TYPE_PARAMS_OF_func()) The capitalized names like DEFAULT_OF_arg are not actually bound at runtime. DEFAULT_OF_arg ### 8. 10. 2. Generic classes¶ Generic classes are declared as follows: class Bag[T]:. This syntax is equivalent to: annotation-def TYPE_PARAMS_OF_Bag(): T = typing. TypeVar(\"T\") class Bag(typing. Generic[T]): __type_params__ = (T,). return Bag Bag = TYPE_PARAMS_OF_Bag() Here again annotation-def (not a real keyword) indicates an annotation scope, and the name TYPE_PARAMS_OF_Bag is not actually bound at runtime. annotation-def TYPE_PARAMS_OF_Bag Generic classes implicitly inherit from typing. Generic. The base classes and keyword arguments of generic classes are evaluated within the type scope for the type parameters, and decorators are evaluated outside that scope. This is illustrated by this example: typing. Generic @decorator class Bag(Base[T], arg=T):. This is equivalent to: annotation-def TYPE_PARAMS_OF_Bag(): T = typing. TypeVar(\"T\") class Bag(Base[T], typing. Generic[T], arg=T): __type_params__ = (T,). return Bag Bag = decorator(TYPE_PARAMS_OF_Bag()) ### 8. 10. 3.",
  "title": "8. Compound statements.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 28,
  "start_char": 65233,
  "end_char": 67150,
  "token_count": 454,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_ec1b46183acd657b.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:27.390053"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30_chunk_028.txt"
}