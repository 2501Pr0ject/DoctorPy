Backslashes are also allowed in replacement fields and are evaluated the same way as in any other context: >>> a = ["a", "b", "c"] >>> print(f"List a contains:\n{"\n". join(a)}") List a contains: a b c Changed in version 3. 12: Prior to Python 3. 12, backslashes were not permitted inside an f-string replacement field. Formatted string literals cannot be used as docstrings, even if they do not include expressions. >>> def foo():. f"Not a docstring". >>> foo. __doc__ is None True See also PEP 498 for the proposal that added formatted string literals, and str. format(), which uses a related format string mechanism. str. format() ### 2. 4. 4. Numeric literals¶ There are three types of numeric literals: integers, floating-point numbers, and imaginary numbers. There are no complex literals (complex numbers can be formed by adding a real number and an imaginary number). Note that numeric literals do not include a sign; a phrase like -1 is actually an expression composed of the unary operator ‘-’ and the literal 1. -1 - 1 ### 2. 4. 5. Integer literals¶ Integer literals are described by the following lexical definitions: integer ::= decinteger | bininteger | octinteger | hexinteger decinteger ::= nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")* bininteger ::= "0" ("b" | "B") (["_"] bindigit)+ octinteger ::= "0" ("o" | "O") (["_"] octdigit)+ hexinteger ::= "0" ("x" | "X") (["_"] hexdigit)+ nonzerodigit ::= "1". "9" digit ::= "0". "9" bindigit ::= "0" | "1" octdigit ::= "0". "7" hexdigit ::= digit | "a". "f" | "A". "F" decinteger bininteger octinteger hexinteger nonzerodigit digit bindigit octdigit hexdigit digit There is no limit for the length of integer literals apart from what can be stored in available memory. Underscores are ignored for determining the numeric value of the literal. They can be used to group digits for enhanced readability. One underscore can occur between digits, and after base specifiers like 0x.