append(k) groupby() is roughly equivalent to: groupby() def groupby(iterable, key=None): # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D keyfunc = (lambda x: x) if key is None else key iterator = iter(iterable) exhausted = False def _grouper(target_key): nonlocal curr_value, curr_key, exhausted yield curr_value for curr_value in iterator: curr_key = keyfunc(curr_value) if curr_key. = target_key: return yield curr_value exhausted = True try: curr_value = next(iterator) except StopIteration: return curr_key = keyfunc(curr_value) while not exhausted: target_key = curr_key curr_group = _grouper(target_key) yield curr_key, curr_group if curr_key == target_key: for _ in curr_group: pass Make an iterator that returns selected elements from the iterable. Works like sequence slicing but does not support negative values for start, stop, or step. If start is zero or None, iteration starts at zero. Otherwise, elements from the iterable are skipped until start is reached. None If stop is None, iteration continues until the input is exhausted, if at all. Otherwise, it stops at the specified position. None If step is None, the step defaults to one. Elements are returned consecutively unless step is set higher than one which results in items being skipped. None Roughly equivalent to: def islice(iterable, *args): # islice('ABCDEFG', 2) → A B # islice('ABCDEFG', 2, 4) → C D # islice('ABCDEFG', 2, None) → C D E F G # islice('ABCDEFG', 0, None, 2) → A C E G s = slice(*args) start = 0 if s. start is None else s. start stop = s. stop step = 1 if s. step is None else s.