If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). maxsplit+1 -1 If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'. split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence as a single delimiter. Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. b'1,,2'. split(b',') [b'1', b'', b'2'] [b''] [bytearray(b'')] For example: >>> b'1,2,3'. split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'. split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'. split(b',') [b'1', b'2', b'', b'3', b''] >>> b'1<>2<>3<4'. split(b'<>') [b'1', b'2', b'3<4'] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. None [] For example: >>> b'1 2 3'. split() [b'1', b'2', b'3'] >>> b'1 2 3'. split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '. split() [b'1', b'2', b'3'] Return a copy of the sequence with specified leading and trailing bytes removed.