{
  "chunk_id": "python_official_python_official_reference_d33d7142ec98a66a_04aff2e9a15c_chunk_018",
  "original_doc_id": "python_official_python_official_reference_d33d7142ec98a66a_04aff2e9a15c",
  "content": "__spec__ None When Python is started with the -m option, spec is set to the module spec of the corresponding module or package. spec is also populated when the main module is loaded as part of executing a directory, zipfile or other sys. path entry. -m __spec__ __spec__ __main__ sys. path In the remaining cases main. spec is set to None, as the code used to populate the main does not correspond directly with an importable module: __main__. __spec__ None __main__ interactive prompt interactive prompt -c option -c option -c running from stdin running from stdin running directly from a source or bytecode file running directly from a source or bytecode file Note that main. spec is always None in the last case, even if the file could technically be imported directly as a module instead. Use the -m switch if valid module metadata is desired in main. __main__. __spec__ None -m __main__ Note also that even when main corresponds with an importable module and main. spec is set accordingly, they’re still considered distinct modules. This is due to the fact that blocks guarded by if name == \"main\": checks only execute when the module is used to populate the main namespace, and not during normal import. __main__ __main__. __spec__ if __name__ == \"__main__\": __main__ ## 5. 9. References¶ The import machinery has evolved considerably since Python’s early days. The original specification for packages is still available to read, although some details have changed since the writing of that document. The original specification for sys. meta_path was PEP 302, with subsequent extension in PEP 420. sys. meta_path PEP 420 introduced namespace packages for Python 3. 3. PEP 420 also introduced the find_loader() protocol as an alternative to find_module(). find_loader() find_module() PEP 366 describes the addition of the package attribute for explicit relative imports in main modules. __package__ PEP 328 introduced absolute and explicit relative imports and initially proposed name for semantics PEP 366 would eventually specify for package. __name__ __package__ PEP 338 defines executing modules as scripts. PEP 451 adds the encapsulation of per-module import state in spec objects. It also off-loads most of the boilerplate responsibilities of loaders back onto the import machinery.",
  "title": "5. The import system.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 18,
  "start_char": 41386,
  "end_char": 43679,
  "token_count": 488,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_d33d7142ec98a66a.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:39.018383"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_d33d7142ec98a66a_04aff2e9a15c_chunk_018.txt"
}