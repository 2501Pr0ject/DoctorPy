\g uses the corresponding group number; \g<2> is therefore equivalent to \2, but isn’t ambiguous in a replacement such as \g<2>0. \20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. The backreference \g<0> substitutes in the entire substring matched by the RE. \g<name> name (. P<name>. ) \g<number> \g<2> \2 \g<2>0 \20 '0' \g<0> The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the | operator). | Changed in version 3. 1: Added the optional flags argument. Changed in version 3. 5: Unmatched groups are replaced with an empty string. Changed in version 3. 6: Unknown escapes in pattern consisting of '\' and an ASCII letter now are errors. '\' Changed in version 3. 7: Unknown escapes in repl consisting of '\' and an ASCII letter now are errors. An empty match can occur immediately after a non-empty match. '\' Changed in version 3. 12: Group id can only contain ASCII digits. In bytes replacement strings, group name can only contain bytes in the ASCII range (b'\x00'-b'\x7f'). bytes b'\x00' b'\x7f' Deprecated since version 3. 13: Passing count and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). sub() (new_string, number_of_subs_made) The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the | operator). | Escape special characters in pattern. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example: >>> print(re. escape('  >>> legal_chars = string. ascii_lowercase + string. digits + ". #$%&'*+-. ^_|~:" >>> print('[%s]+' % re. escape(legal_chars)) [abcdefghijklmnopqrstuvwxyz0123456789. \#\$%\&'\*\+\-\.