These methods are called to implement the binary arithmetic operations (+, -, *, @, /, //, %, divmod(), pow(), , <<, >>, &, ^, |). For instance, to evaluate the expression x + y, where x is an instance of a class that has an add() method, type(x). add(x, y) is called. The divmod() method should be the equivalent to using floordiv() and mod(); it should not be related to truediv(). Note that pow() should be defined to accept an optional third argument if the ternary version of the built-in pow() function is to be supported. + - * @ / // % divmod() pow() ** << >> & ^ | x + y __add__() type(x). __add__(x, y) __divmod__() __floordiv__() __mod__() __truediv__() __pow__() pow() If one of those methods does not support the operation with the supplied arguments, it should return NotImplemented. NotImplemented These methods are called to implement the binary arithmetic operations (+, -, , @, /, //, %, divmod(), pow(), , <<, >>, &, ^, |) with reflected (swapped) operands. These functions are only called if the left operand does not support the corresponding operation [3] and the operands are of different types. [4] For instance, to evaluate the expression x - y, where y is an instance of a class that has an rsub() method, type(y). rsub(y, x) is called if type(x). sub(x, y) returns NotImplemented. + - * @ / // % divmod() pow() ** << >> & ^ | x - y __rsub__() type(y). __rsub__(y, x) type(x). __sub__(x, y) NotImplemented Note that ternary pow() will not try calling rpow() (the coercion rules would become too complicated). pow() __rpow__() Note If the right operand’s type is a subclass of the left operand’s type and that subclass provides a different implementation of the reflected method for the operation, this method will be called before the left operand’s non-reflected method. This behavior allows subclasses to override their ancestors’ operations.