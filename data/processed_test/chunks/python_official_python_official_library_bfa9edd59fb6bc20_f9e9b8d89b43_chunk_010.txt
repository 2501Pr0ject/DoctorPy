0 gives a different hexadecimal string representing the same number: 3740. 0 >>> float. hex(3740. 0) '0x1. d380000000000p+11' ### Hashing of numeric types¶ For numbers x and y, possibly of different types, it’s a requirement that hash(x) == hash(y) whenever x == y (see the hash() method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including int, float, decimal. Decimal and fractions. Fraction) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of int and fractions. Fraction, and all finite instances of float and decimal. Decimal. Essentially, this function is given by reduction modulo P for a fixed prime P. The value of P is made available to Python as the modulus attribute of sys. hash_info. x y hash(x) == hash(y) x == y __hash__() int float decimal. Decimal fractions. Fraction int fractions. Fraction float decimal. Decimal P P P modulus sys. hash_info CPython implementation detail: Currently, the prime used is P = 231 - 1 on machines with 32-bit C longs and P = 261 - 1 on machines with 64-bit C longs. P = 2**31 - 1 P = 2**61 - 1 Here are the rules in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. x = m / n n P hash(x) m * invmod(n, P) % P invmod(n, P) n P If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesn’t apply; in this case define hash(x) to be the constant value sys. hash_info. inf.