HTTPError #### Error Codes¶ Because the default handlers handle redirects (codes in the 300 range), and codes in the 100–299 range indicate success, you will usually only see error codes in the 400–599 range. http. server. BaseHTTPRequestHandler. responses is a useful dictionary of response codes that shows all the response codes used by RFC 2616. An excerpt from the dictionary is shown below http. server. BaseHTTPRequestHandler. responses responses = {. <HTTPStatus. OK: 200>: ('OK', 'Request fulfilled, document follows'),. <HTTPStatus. FORBIDDEN: 403>: ('Forbidden', 'Request forbidden -- authorization will ' 'not help'), <HTTPStatus. NOT_FOUND: 404>: ('Not Found', 'Nothing matches the given URI'),. <HTTPStatus. IM_A_TEAPOT: 418>: ("I'm a Teapot", 'Server refuses to brew coffee because ' 'it is a teapot'),. <HTTPStatus. SERVICE_UNAVAILABLE: 503>: ('Service Unavailable', 'The server cannot process the ' 'request due to a high load'),. } When an error is raised the server responds by returning an HTTP error code and an error page. You can use the HTTPError instance as a response on the page returned. This means that as well as the code attribute, it also has read, geturl, and info, methods as returned by the urllib. response module: HTTPError urllib. response >>> req = urllib. request. Request(' >>> try:. urllib. request. urlopen(req). except urllib. error. HTTPError as e:. print(e. code). print(e. read()). 404 b'<. DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1. 0 Transitional//EN" ". <title>Page Not Found</title>\n. ### Wrapping it Up¶ So if you want to be prepared for HTTPError or URLError there are two basic approaches. I prefer the second approach. HTTPError URLError #### Number 1¶ from urllib. request import Request, urlopen from urllib. error import URLError, HTTPError req = Request(someurl) try: response = urlopen(req) except HTTPError as e: print('The server couldn\'t fulfill the request. ') print('Error code: ', e. code) except URLError as e: print('We failed to reach a server.