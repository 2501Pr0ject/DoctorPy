') print('Reason: ', e. reason) else: # everything is fine Note The except HTTPError must come first, otherwise except URLError will also catch an HTTPError. except HTTPError except URLError HTTPError #### Number 2¶ from urllib. request import Request, urlopen from urllib. error import URLError req = Request(someurl) try: response = urlopen(req) except URLError as e: if hasattr(e, 'reason'): print('We failed to reach a server. ') print('Reason: ', e. reason) elif hasattr(e, 'code'): print('The server couldn\'t fulfill the request. ') print('Error code: ', e. code) else: # everything is fine ## info and geturl¶ The response returned by urlopen (or the HTTPError instance) has two useful methods info() and geturl() and is defined in the module urllib. response. HTTPError info() geturl() urllib. response geturl - this returns the real URL of the page fetched. This is useful because urlopen (or the opener object used) may have followed a redirect. The URL of the page fetched may not be the same as the URL requested. geturl - this returns the real URL of the page fetched. This is useful because urlopen (or the opener object used) may have followed a redirect. The URL of the page fetched may not be the same as the URL requested. urlopen info - this returns a dictionary-like object that describes the page fetched, particularly the headers sent by the server. It is currently an http. client. HTTPMessage instance. info - this returns a dictionary-like object that describes the page fetched, particularly the headers sent by the server. It is currently an http. client. HTTPMessage instance. http. client. HTTPMessage Typical headers include ‘Content-length’, ‘Content-type’, and so on. See the Quick Reference to HTTP Headers for a useful listing of HTTP headers with brief explanations of their meaning and use. ## Openers and Handlers¶ When you fetch a URL you use an opener (an instance of the perhaps confusingly named urllib. request. OpenerDirector). Normally we have been using the default opener - via urlopen - but you can create custom openers. Openers use handlers. All the “heavy lifting” is done by the handlers. Each handler knows how to open URLs for a particular URL scheme (http, ftp, etc.