WRAPPER_ASSIGNMENTS __module__ __name__ __qualname__ __annotations__ __type_params__ __doc__ WRAPPER_UPDATES __dict__ To allow access to the original function for introspection and other purposes (e. g. bypassing a caching decorator such as lru_cache()), this function automatically adds a wrapped attribute to the wrapper that refers to the function being wrapped. lru_cache() __wrapped__ The main intended use for this function is in decorator functions which wrap the decorated function and return the wrapper. If the wrapper function is not updated, the metadata of the returned function will reflect the wrapper definition rather than the original function definition, which is typically less than helpful. update_wrapper() may be used with callables other than functions. Any attributes named in assigned or updated that are missing from the object being wrapped are ignored (i. e. this function will not attempt to set them on the wrapper function). AttributeError is still raised if the wrapper function itself is missing any attributes named in updated. update_wrapper() AttributeError Changed in version 3. 2: The wrapped attribute is now automatically added. The annotations attribute is now copied by default. Missing attributes no longer trigger an AttributeError. __wrapped__ __annotations__ AttributeError Changed in version 3. 4: The wrapped attribute now always refers to the wrapped function, even if that function defined a wrapped attribute. (see bpo-17482) __wrapped__ __wrapped__ Changed in version 3. 12: The type_params attribute is now copied by default. __type_params__ This is a convenience function for invoking update_wrapper() as a function decorator when defining a wrapper function. It is equivalent to partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated). For example: update_wrapper() partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) >>> from functools import wraps >>> def my_decorator(f):. @wraps(f). def wrapper(*args, **kwds):. print('Calling decorated function'). return f(*args, **kwds). return wrapper. >>> @my_decorator. def example():. """Docstring""". print('Called example function'). >>> example() Calling decorated function Called example function >>> example. __name__ 'example' >>> example.