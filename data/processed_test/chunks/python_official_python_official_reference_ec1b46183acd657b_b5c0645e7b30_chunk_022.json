{
  "chunk_id": "python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30_chunk_022",
  "original_doc_id": "python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30",
  "content": "*identifier **identifier * *identifier / Changed in version 3. 8: The / function parameter syntax may be used to indicate positional-only parameters. See PEP 570 for details. / Parameters may have an annotation of the form “: expression” following the parameter name. Any parameter may have an annotation, even those of the form identifier or identifier. (As a special case, parameters of the form identifier may have an annotation “: expression”. ) Functions may have “return” annotation of the form “-> expression” after the parameter list. These annotations can be any valid Python expression. The presence of annotations does not change the semantics of a function. The annotation values are available as values of a dictionary keyed by the parameters’ names in the annotations attribute of the function object. If the annotations import from future is used, annotations are preserved as strings at runtime which enables postponed evaluation. Otherwise, they are evaluated when the function definition is executed. In this case annotations may be evaluated in a different order than they appear in the source code. : expression *identifier **identifier *identifier : *expression -> expression __annotations__ annotations __future__ Changed in version 3. 11: Parameters of the form “identifier” may have an annotation “: expression”. See PEP 646. *identifier : *expression It is also possible to create anonymous functions (functions not bound to a name), for immediate use in expressions. This uses lambda expressions, described in section Lambdas. Note that the lambda expression is merely a shorthand for a simplified function definition; a function defined in a “def” statement can be passed around or assigned to another name just like a function defined by a lambda expression. The “def” form is actually more powerful since it allows the execution of multiple statements and annotations. def def Programmer’s note: Functions are first-class objects. A “def” statement executed inside a function definition defines a local function that can be returned or passed around. Free variables used in the nested function can access the local variables of the function containing the def. See section Naming and binding for details. def See also The original specification for function annotations. Definition of a standard meaning for annotations: type hints. Ability to type hint variable declarations, including class variables and instance variables. Support for forward references within annotations by preserving annotations in a string form at runtime instead of eager evaluation. Function and method decorators were introduced. Class decorators were introduced in PEP 3129. ## 8.",
  "title": "8. Compound statements.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 22,
  "start_char": 51297,
  "end_char": 53985,
  "token_count": 500,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_ec1b46183acd657b.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:27.385017"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30_chunk_022.txt"
}