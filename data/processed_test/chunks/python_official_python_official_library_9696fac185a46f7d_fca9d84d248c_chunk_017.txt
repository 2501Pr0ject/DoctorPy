" # iter_index('AABCADEAF', 'A') → 0 1 4 7 seq_index = getattr(iterable, 'index', None) if seq_index is None: iterator = islice(iterable, start, stop) for i, element in enumerate(iterator, start): if element is value or element == value: yield i else: stop = len(iterable) if stop is None else stop i = start with suppress(ValueError): while True: yield (i := seq_index(value, i, stop)) i += 1 def iter_except(function, exception, first=None): "Convert a call-until-exception interface to an iterator interface. " # iter_except(d. popitem, KeyError) → non-blocking dictionary iterator with suppress(exception): if first is not None: yield first() while True: yield function() The following recipes have a more mathematical flavor: def multinomial(*counts): "Number of distinct arrangements of a multiset. " # Counter('abracadabra'). values() → 5 2 2 1 1 # multinomial(5, 2, 2, 1, 1) → 83160 return prod(map(comb, accumulate(counts), counts)) def powerset(iterable): "Subsequences of the iterable from shortest to longest. " # powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3) s = list(iterable) return chain. from_iterable(combinations(s, r) for r in range(len(s)+1)) def sum_of_squares(iterable): "Add up the squares of the input values. " # sum_of_squares([10, 20, 30]) → 1400 return sumprod(*tee(iterable)) def reshape(matrix, columns): "Reshape a 2-D matrix to have a given number of columns. " # reshape([(0, 1), (2, 3), (4, 5)], 3) → (0, 1, 2), (3, 4, 5) return batched(chain. from_iterable(matrix), columns, strict=True) def transpose(matrix): "Swap the rows and columns of a 2-D matrix.