from_iterable(['ABC', 'DEF']) → A B C D E F compress() compress('ABCDEF', [1,0,1,0,1,1]) → A C E F dropwhile() dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8 filterfalse() filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8 groupby() groupby(['A','B','DEF'], len) → (1, A B) (3, DEF) islice() islice('ABCDEFG', 2, None) → C D E F G pairwise() pairwise('ABCDEFG') → AB BC CD DE EF FG starmap() starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000 takewhile() takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4 tee() zip_longest() zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D- product() permutations() combinations() combinations_with_replacement() product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD permutations('ABCD', 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations('ABCD', 2) AB AC AD BC BD CD combinations_with_replacement('ABCD', 2) AA AB AC AD BB BC BD CC CD DD def accumulate(iterable, function=operator. add, *, initial=None): 'Return running totals' # accumulate([1,2,3,4,5]) → 1 3 6 10 15 # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115 # accumulate([1,2,3,4,5], operator. mul) → 1 2 6 24 120 iterator = iter(iterable) total = initial if initial is None: try: total = next(iterator) except StopIteration: return yield total for element in iterator: total = function(total, element) yield total min() max() operator.