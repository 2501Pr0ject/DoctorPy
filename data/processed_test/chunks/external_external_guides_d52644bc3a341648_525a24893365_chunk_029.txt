Toplevel(master, class_='ClassName') __double_leading_underscore __boo _FooBar__boo __double_leading_and_trailing_underscore__ __init__ __import__ __file__ _socket T AnyStr Num _co _contra from typing import TypeVar VT_co = TypeVar('VT_co', covariant=True) KT_contra = TypeVar('KT_contra', contravariant=True) from M import * __all__ self cls class_ clss __a Foo. __a Foo. _Foo__a MAX_OVERFLOW TOTAL __getattr__() __all__ __all__ __all__ os. path __init__ a += b a = a + b ''. join() is is not if x if x is not None is not not. is # Correct: if foo is not None: # Wrong: if not foo is None: __eq__ __ne__ __lt__ __le__ __gt__ __ge__ functools. total_ordering() y > x x < y y >= x x <= y x == y x. = y sort() min() < max() > # Correct: def f(x): return 2*x # Wrong: f = lambda x: 2*x Exception BaseException BaseException raise X from Y raise X from None except: try: import platform_specific_module except ImportError: platform_specific_module = None except: except Exception: except BaseException: raise try. finally errno try # Correct: try: value = collection[key] except KeyError: return key_not_found(key) else: return handle_value(value) # Wrong: try: # Too broad. return handle_value(collection[key]) except KeyError: # Will also catch KeyError raised by handle_value() return key_not_found(key) with # Correct: with conn. begin_transaction(): do_stuff_in_transaction(conn) # Wrong: with conn: do_stuff_in_transaction(conn) __enter__ __exit__ return None # Correct: def foo(x): if x >= 0: return math. sqrt(x) else: return None def bar(x): if x < 0: return None return math. sqrt(x) # Wrong: def foo(x): if x >= 0: return math. sqrt(x) def bar(x): if x < 0: return return math. sqrt(x) ''. startswith() ''. endswith() # Correct: if foo.