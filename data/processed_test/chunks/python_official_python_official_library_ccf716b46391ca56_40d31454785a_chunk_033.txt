findall(r"\w+ly\b", text) ['carefully', 'quickly'] ### Finding all Adverbs and their Positions¶ If one wants more information about all matches of a pattern than the matched text, finditer() is useful as it provides Match objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use finditer() in the following manner: finditer() Match finditer() >>> text = "He was carefully disguised but captured quickly by police. " >>> for m in re. finditer(r"\w+ly\b", text):. print('%02d-%02d: %s' % (m. start(), m. end(), m. group(0))) 07-16: carefully 40-47: quickly ### Raw String Notation¶ Raw string notation (r"text") keeps regular expressions sane. Without it, every backslash ('\') in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: r"text" '\' >>> re. match(r"\W(. )\1\W", " ff ") <re. Match object; span=(0, 4), match=' ff '> >>> re. match("\\W(. )\\1\\W", " ff ") <re. Match object; span=(0, 4), match=' ff '> When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means r"\". Without raw string notation, one must use "\\", making the following lines of code functionally identical: r"\\" "\\\\" >>> re. match(r"\\", r"\\") <re. Match object; span=(0, 1), match='\\'> >>> re. match("\\\\", r"\\") <re. Match object; span=(0, 1), match='\\'> ### Writing a Tokenizer¶ A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions.