{
  "chunk_id": "python_official_python_official_library_bfa9edd59fb6bc20_f9e9b8d89b43_chunk_083",
  "original_doc_id": "python_official_python_official_library_bfa9edd59fb6bc20_f9e9b8d89b43",
  "content": "For example, int | \"Foo\", where \"Foo\" is a reference to a class not yet defined, will fail at runtime. For unions which include forward references, present the whole expression as a string, e. g. \"int | Foo\". | int | \"Foo\" \"Foo\" \"int | Foo\" Union objects can be tested for equality with other union objects. Details: Unions of unions are flattened: (int | str) | float == int | str | float Unions of unions are flattened: (int | str) | float == int | str | float Redundant types are removed: int | str | int == int | str Redundant types are removed: int | str | int == int | str When comparing unions, the order is ignored: int | str == str | int When comparing unions, the order is ignored: int | str == str | int It is compatible with typing. Union: int | str == typing. Union[int, str] It is compatible with typing. Union: typing. Union int | str == typing. Union[int, str] Optional types can be spelled as a union with None: str | None == typing. Optional[str] Optional types can be spelled as a union with None: None str | None == typing. Optional[str] Calls to isinstance() and issubclass() are also supported with a union object: isinstance() issubclass() >>> isinstance(\"\", int | str) True However, parameterized generics in union objects cannot be checked: >>> isinstance(1, int | list[int]) # short-circuit evaluation True >>> isinstance([1], int | list[int]) Traceback (most recent call last):. TypeError: isinstance() argument 2 cannot be a parameterized generic The user-exposed type for the union object can be accessed from types. UnionType and used for isinstance() checks. An object cannot be instantiated from the type: types. UnionType isinstance() >>> import types >>> isinstance(int | str, types. UnionType) True >>> types. UnionType() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: cannot create 'types. UnionType' instances Note The or() method for type objects was added to support the syntax X | Y. If a metaclass implements or(), the Union may override it: __or__() X | Y __or__() >>> class M(type):. def __or__(self, other):.",
  "title": "Built-in Types.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 83,
  "start_char": 170207,
  "end_char": 172294,
  "token_count": 500,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_bfa9edd59fb6bc20.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:56:56.254834"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_bfa9edd59fb6bc20_f9e9b8d89b43_chunk_083.txt"
}