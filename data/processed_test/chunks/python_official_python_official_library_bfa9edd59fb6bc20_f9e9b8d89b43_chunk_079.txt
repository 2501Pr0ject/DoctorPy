group(0) x[0] str GenericAlias re. Match[str] If y = re. search(b'bar', b'bar'), (note the b for bytes), y will also be an instance of re. Match, but the return values of y. group(0) and y[0] will both be of type bytes. In type annotations, we would represent this variety of re. Match objects with re. Match[bytes]. If y = re. search(b'bar', b'bar'), (note the b for bytes), y will also be an instance of re. Match, but the return values of y. group(0) and y[0] will both be of type bytes. In type annotations, we would represent this variety of re. Match objects with re. Match[bytes]. y = re. search(b'bar', b'bar') b bytes y re. Match y. group(0) y[0] bytes re. Match[bytes] GenericAlias objects are instances of the class types. GenericAlias, which can also be used to create GenericAlias objects directly. GenericAlias types. GenericAlias GenericAlias Creates a GenericAlias representing a type T parameterized by types X, Y, and more depending on the T used. For example, a function expecting a list containing float elements: GenericAlias T T list float def average(values: list[float]) -> float: return sum(values) / len(values) Another example for mapping objects, using a dict, which is a generic type expecting two type parameters representing the key type and the value type. In this example, the function expects a dict with keys of type str and values of type int: dict dict str int def send_post_request(url: str, body: dict[str, int]) -> None:. The builtin functions isinstance() and issubclass() do not accept GenericAlias types for their second argument: isinstance() issubclass() GenericAlias >>> isinstance([1, 2], list[str]) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: isinstance() argument 2 cannot be a parameterized generic The Python runtime does not enforce type annotations. This extends to generic types and their type parameters. When creating a container object from a GenericAlias, the elements in the container are not checked against their type.