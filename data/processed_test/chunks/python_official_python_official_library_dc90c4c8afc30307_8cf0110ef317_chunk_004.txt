Python’s x % y returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but the result of Python’s -1e-100 % 1e100 is 1e100-1e-100, which cannot be represented exactly as a float, and rounds to the surprising 1e100. For this reason, function fmod() is generally preferred when working with floats, while Python’s x % y is preferred when working with integers. x / y fmod(x, y) x % y fmod(x, y) x - n*y abs(y) x % y fmod(-1e-100, 1e100) -1e-100 -1e-100 % 1e100 1e100-1e-100 1e100 fmod() x % y Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that modf() has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). modf() Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0. 5 * abs(y). x - n*y n x / y x / y n r = remainder(x, y) abs(r) <= 0. 5 * abs(y) Special cases follow IEEE 754: in particular, remainder(x, math. inf) is x for any finite x, and remainder(x, 0) and remainder(math. inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. remainder(x, math. inf) remainder(x, 0) remainder(math.