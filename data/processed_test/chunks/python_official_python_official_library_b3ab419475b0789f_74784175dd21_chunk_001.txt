py')] Navigating inside a directory tree: >>> p = Path('/etc') >>> q = p / 'init. d' / 'reboot' >>> q PosixPath('/etc/init. d/reboot') >>> q. resolve() PosixPath('/etc/rc. d/init. d/halt') Querying path properties: >>> q. exists() True >>> q. is_dir() False Opening a file: >>> with q. open() as f: f. readline(). '#. /bin/bash\n' ## Exceptions¶ An exception inheriting NotImplementedError that is raised when an unsupported operation is called on a path object. NotImplementedError Added in version 3. 13. ## Pure paths¶ Pure path objects provide path-handling operations which don’t actually access a filesystem. There are three ways to access these classes, which we also call flavours: A generic class that represents the system’s path flavour (instantiating it creates either a PurePosixPath or a PureWindowsPath): PurePosixPath PureWindowsPath >>> PurePath('setup. py') # Running on a Unix machine PurePosixPath('setup. py') Each element of pathsegments can be either a string representing a path segment, or an object implementing the os. PathLike interface where the fspath() method returns a string, such as another path object: os. PathLike __fspath__() >>> PurePath('foo', 'some/path', 'bar') PurePosixPath('foo/some/path/bar') >>> PurePath(Path('foo'), Path('bar')) PurePosixPath('foo/bar') When pathsegments is empty, the current directory is assumed: >>> PurePath() PurePosixPath('. ') If a segment is an absolute path, all previous segments are ignored (like os. path. join()): os. path. join() >>> PurePath('/etc', '/usr', 'lib64') PurePosixPath('/usr/lib64') >>> PureWindowsPath('c:/Windows', 'd:bar') PureWindowsPath('d:bar') On Windows, the drive is not reset when a rooted relative path segment (e. g. , r'\foo') is encountered: r'\foo' >>> PureWindowsPath('c:/Windows', '/Program Files') PureWindowsPath('c:/Program Files') Spurious slashes and single dots are collapsed, but double dots ('.