identifier ::= xid_start xid_continue* id_start ::= <all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property> id_continue ::= <all characters in id_start, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property> xid_start ::= <all characters in id_start whose NFKC normalization is in "id_start xid_continue*"> xid_continue ::= <all characters in id_continue whose NFKC normalization is in "id_continue*"> xid_start xid_continue id_start id_start id_continue The Unicode category codes mentioned above stand for: Lu - uppercase letters Lu - uppercase letters Ll - lowercase letters Ll - lowercase letters Lt - titlecase letters Lt - titlecase letters Lm - modifier letters Lm - modifier letters Lo - other letters Lo - other letters Nl - letter numbers Nl - letter numbers Mn - nonspacing marks Mn - nonspacing marks Mc - spacing combining marks Mc - spacing combining marks Nd - decimal numbers Nd - decimal numbers Pc - connector punctuations Pc - connector punctuations Other_ID_Start - explicit list of characters in PropList. txt to support backwards compatibility Other_ID_Start - explicit list of characters in PropList. txt to support backwards compatibility Other_ID_Continue - likewise Other_ID_Continue - likewise All identifiers are converted into the normal form NFKC while parsing; comparison of identifiers is based on NFKC. A non-normative HTML file listing all valid identifier characters for Unicode 15. 1. 0 can be found at  ### 2. 3. 1. Keywords¶ The following identifiers are used as reserved words, or keywords of the language, and cannot be used as ordinary identifiers. They must be spelled exactly as written here: False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield ### 2. 3. 2. Soft Keywords¶ Added in version 3. 10. Some identifiers are only reserved under specific contexts. These are known as soft keywords. The identifiers match, case, type and _ can syntactically act as keywords in certain contexts, but this distinction is done at the parser level, not when tokenizing.