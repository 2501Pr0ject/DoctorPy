{
  "chunk_id": "python_official_python_official_library_9696fac185a46f7d_fca9d84d248c_chunk_015",
  "original_doc_id": "python_official_python_official_library_9696fac185a46f7d_fca9d84d248c",
  "content": "\" # Use functions that consume iterators at C speed. if n is None: deque(iterator, maxlen=0) else: next(islice(iterator, n, n), None) def nth(iterable, n, default=None): \"Returns the nth item or a default value. \" return next(islice(iterable, n, None), default) def quantify(iterable, predicate=bool): \"Given a predicate that returns True or False, count the True results. \" return sum(map(predicate, iterable)) def first_true(iterable, default=False, predicate=None): \"Returns the first true value or the *default* if there is no true value. \" # first_true([a,b,c], x) → a or b or c or x # first_true([a,b], x, f) → a if f(a) else b if f(b) else x return next(filter(predicate, iterable), default) def all_equal(iterable, key=None): \"Returns True if all the elements are equal to each other. \" # all_equal('4٤௪౪໔', key=int) → True return len(take(2, groupby(iterable, key))) <= 1 def unique_justseen(iterable, key=None): \"Yield unique elements, preserving order. Remember only the element just seen. \" # unique_justseen('AAAABBBCCDAABBB') → A B C D A B # unique_justseen('ABBcCAD', str. casefold) → A B c A D if key is None: return map(itemgetter(0), groupby(iterable)) return map(next, map(itemgetter(1), groupby(iterable, key))) def unique_everseen(iterable, key=None): \"Yield unique elements, preserving order. Remember all elements ever seen. \" # unique_everseen('AAAABBBCCDAABBB') → A B C D # unique_everseen('ABBcCAD', str. casefold) → A B c D seen = set() if key is None: for element in filterfalse(seen. __contains__, iterable): seen. add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen. add(k) yield element def unique(iterable, key=None, reverse=False): \"Yield unique elements in sorted order. Supports unhashable inputs.",
  "title": "itertools — Functions creating iterators for efficient looping.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 15,
  "start_char": 26642,
  "end_char": 28420,
  "token_count": 494,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_9696fac185a46f7d.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:02.106852"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_9696fac185a46f7d_fca9d84d248c_chunk_015.txt"
}