{
  "chunk_id": "python_official_python_official_library_96003c24587351a2_74918d6d2a40_chunk_005",
  "original_doc_id": "python_official_python_official_library_96003c24587351a2_74918d6d2a40",
  "content": "compiler_flag _Feature __future__ ast PyCF_ The argument optimize specifies the optimization level of the compiler; the default value of -1 selects the optimization level of the interpreter as given by -O options. Explicit levels are 0 (no optimization; debug is true), 1 (asserts are removed, debug is false) or 2 (docstrings are removed too). -1 -O 0 __debug__ 1 __debug__ 2 This function raises SyntaxError if the compiled source is invalid, and ValueError if the source contains null bytes. SyntaxError ValueError If you want to parse Python code into its AST representation, see ast. parse(). ast. parse() Raises an auditing event compile with arguments source and filename. This event may also be raised by implicit compilation. Raises an auditing event compile with arguments source and filename. This event may also be raised by implicit compilation. compile source filename Note When compiling a string with multi-line code in 'single' or 'eval' mode, input must be terminated by at least one newline character. This is to facilitate detection of incomplete and complete statements in the code module. 'single' 'eval' code Warning It is possible to crash the Python interpreter with a sufficiently large/complex string when compiling to an AST object due to stack depth limitations in Pythonâ€™s AST compiler. Changed in version 3. 2: Allowed use of Windows and Mac newlines. Also, input in 'exec' mode does not have to end in a newline anymore. Added the optimize parameter. 'exec' Changed in version 3. 5: Previously, TypeError was raised when null bytes were encountered in source. TypeError Added in version 3. 8: ast. PyCF_ALLOW_TOP_LEVEL_AWAIT can now be passed in flags to enable support for top-level await, async for, and async with. ast. PyCF_ALLOW_TOP_LEVEL_AWAIT await async for async with Convert a single string or number to a complex number, or create a complex number from real and imaginary parts. Examples: >>> complex('+1. 23') (1. 23+0j) >>> complex('-4. 5j') -4. 5j >>> complex('-1. 23+4. 5j') (-1. 23+4. 5j) >>> complex('\\t( -1. 23+4. 5J )\\n') (-1. 23+4.",
  "title": "Built-in Functions.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 5,
  "start_char": 10605,
  "end_char": 12688,
  "token_count": 498,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_96003c24587351a2.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:30.998604"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_96003c24587351a2_74918d6d2a40_chunk_005.txt"
}