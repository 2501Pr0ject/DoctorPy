a op1 b op2 c. y opN z a op1 b and b op2 c and. y opN z Note that a op1 b op2 c doesn’t imply any kind of comparison between a and c, so that, e. g. , x < y > z is perfectly legal (though perhaps not pretty). a op1 b op2 c x < y > z ### 6. 10. 1. Value comparisons¶ The operators <, >, ==, >=, <=, and. = compare the values of two objects. The objects do not need to have the same type. < > == >= <=. = Chapter Objects, values and types states that objects have a value (in addition to type and identity). The value of an object is a rather abstract notion in Python: For example, there is no canonical access method for an object’s value. Also, there is no requirement that the value of an object should be constructed in a particular way, e. g. comprised of all its data attributes. Comparison operators implement a particular notion of what the value of an object is. One can think of them as defining the value of an object indirectly, by means of their comparison implementation. Because all types are (direct or indirect) subtypes of object, they inherit the default comparison behavior from object. Types can customize their comparison behavior by implementing rich comparison methods like lt(), described in Basic customization. object object __lt__() The default behavior for equality comparison (== and. =) is based on the identity of the objects. Hence, equality comparison of instances with the same identity results in equality, and equality comparison of instances with different identities results in inequality. A motivation for this default behavior is the desire that all objects should be reflexive (i. e. x is y implies x == y). ==. = x is y x == y A default order comparison (<, >, <=, and >=) is not provided; an attempt raises TypeError. A motivation for this default behavior is the lack of a similar invariant as for equality. < > <= >= TypeError The behavior of the default equality comparison, that instances with different identities are always unequal, may be in contrast to what types will need that have a sensible definition of object value and value-based equality. Such types will need to customize their comparison behavior, and in fact, a number of built-in types have done that.