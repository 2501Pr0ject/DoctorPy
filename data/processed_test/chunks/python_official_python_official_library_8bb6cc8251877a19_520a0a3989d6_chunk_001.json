{
  "chunk_id": "python_official_python_official_library_8bb6cc8251877a19_520a0a3989d6_chunk_001",
  "original_doc_id": "python_official_python_official_library_8bb6cc8251877a19_520a0a3989d6",
  "content": "Subsequent attribute reads and writes take precedence over the cached_property method and it works like a normal attribute. The cached value can be cleared by deleting the attribute. This allows the cached_property method to run again. The cached_property does not prevent a possible race condition in multi-threaded usage. The getter function could run more than once on the same instance, with the latest run setting the cached value. If the cached property is idempotent or otherwise not harmful to run more than once on an instance, this is fine. If synchronization is needed, implement the necessary locking inside the decorated getter function or around the cached property access. Note, this decorator interferes with the operation of PEP 412 key-sharing dictionaries. This means that instance dictionaries can take more space than usual. Also, this decorator requires that the dict attribute on each instance be a mutable mapping. This means it will not work with some types, such as metaclasses (since the dict attributes on type instances are read-only proxies for the class namespace), and those that specify slots without including dict as one of the defined slots (as such classes don’t provide a dict attribute at all). __dict__ __dict__ __slots__ __dict__ __dict__ If a mutable mapping is not available or if space-efficient key sharing is desired, an effect similar to cached_property() can also be achieved by stacking property() on top of lru_cache(). See How do I cache method calls. for more details on how this differs from cached_property(). cached_property() property() lru_cache() cached_property() Added in version 3. 8. Changed in version 3. 12: Prior to Python 3. 12, cached_property included an undocumented lock to ensure that in multi-threaded usage the getter function was guaranteed to run only once per instance. However, the lock was per-property, not per-instance, which could result in unacceptably high lock contention. In Python 3. 12+ this locking is removed. cached_property Transform an old-style comparison function to a key function. Used with tools that accept key functions (such as sorted(), min(), max(), heapq. nlargest(), heapq. nsmallest(), itertools. groupby()). This function is primarily used as a transition tool for programs being converted from Python 2 which supported the use of comparison functions. sorted() min() max() heapq. nlargest() heapq. nsmallest() itertools.",
  "title": "functools — Higher-order functions and operations on callable objects.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 1,
  "start_char": 2369,
  "end_char": 4796,
  "token_count": 494,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_8bb6cc8251877a19.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:09.497701"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_8bb6cc8251877a19_520a0a3989d6_chunk_001.txt"
}