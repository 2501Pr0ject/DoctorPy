append(_tee(iterator)) return tuple(result) class _tee: def __init__(self, iterable): it = iter(iterable) if isinstance(it, _tee): self. iterator = it. iterator self. link = it. link else: self. iterator = it self. link = [None, None] def __iter__(self): return self def __next__(self): link = self. link if link[1] is None: link[0] = next(self. iterator) link[1] = [None, None] value, self. link = link return value tee() tee() def lookahead(tee_iterator): "Return the next value without moving the input forward" [forked_iterator] = tee(tee_iterator, 1) return next(forked_iterator) >>> iterator = iter('abcdef') >>> [iterator] = tee(iterator, 1) # Make the input peekable >>> next(iterator) # Move the iterator forward 'a' >>> lookahead(iterator) # Check next value 'b' >>> next(iterator) # Continue moving forward 'b' tee RuntimeError tee() list() tee() None def zip_longest(*iterables, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') â†’ Ax By C- D- iterators = list(map(iter, iterables)) num_active = len(iterators) if not num_active: return while True: values = [] for i, iterator in enumerate(iterators): try: value = next(iterator) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values. append(value) yield tuple(values) zip_longest() islice() takewhile() chain. from_iterable starmap() repeat() operator collections map() filter() reversed() enumerate() accumulate() compress() pairwise() sliding_window() iter_index() sieve() python -m pip install more-itertools from collections import Counter, deque from contextlib import suppress from functools import reduce from math import comb, prod, sumprod, isqrt from operator import itemgetter, getitem, mul, neg def take(n, iterable): "Return first n items of the iterable as a list. " return list(islice(iterable, n)) def prepend(value, iterable): "Prepend a single value in front of an iterable.