Accordingly, sets are not appropriate arguments for functions which depend on total ordering (for example, min(), max(), and sorted() produce undefined results given a list of sets as inputs). Comparison of sets enforces reflexivity of its elements. Sets (instances of set or frozenset) can be compared within and across their types. set frozenset They define order comparison operators to mean subset and superset tests. Those relations do not define total orderings (for example, the two sets {1,2} and {2,3} are not equal, nor subsets of one another, nor supersets of one another). Accordingly, sets are not appropriate arguments for functions which depend on total ordering (for example, min(), max(), and sorted() produce undefined results given a list of sets as inputs). {1,2} {2,3} min() max() sorted() Comparison of sets enforces reflexivity of its elements. Most other built-in types have no comparison methods implemented, so they inherit the default comparison behavior. Most other built-in types have no comparison methods implemented, so they inherit the default comparison behavior. User-defined classes that customize their comparison behavior should follow some consistency rules, if possible: Equality comparison should be reflexive. In other words, identical objects should compare equal: x is y implies x == y Equality comparison should be reflexive. In other words, identical objects should compare equal: x is y implies x == y x is y x == y Comparison should be symmetric. In other words, the following expressions should have the same result: x == y and y == x x. = y and y. = x x < y and y > x x <= y and y >= x Comparison should be symmetric. In other words, the following expressions should have the same result: x == y and y == x x == y y == x x. = y and y. = x x. = y y. = x x < y and y > x x < y y > x x <= y and y >= x x <= y y >= x Comparison should be transitive. The following (non-exhaustive) examples illustrate that: x > y and y > z implies x > z x < y and y <= z implies x < z Comparison should be transitive.