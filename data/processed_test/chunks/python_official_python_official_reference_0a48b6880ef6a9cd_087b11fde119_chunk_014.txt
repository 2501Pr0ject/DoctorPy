If the primary is a mapping, the expression list must evaluate to an object whose value is one of the keys of the mapping, and the subscription selects the value in the mapping that corresponds to that key. An example of a builtin mapping class is the dict class. dict Sequences. If the primary is a sequence, the expression list must evaluate to an int or a slice (as discussed in the following section). Examples of builtin sequence classes include the str, list and tuple classes. Sequences. If the primary is a sequence, the expression list must evaluate to an int or a slice (as discussed in the following section). Examples of builtin sequence classes include the str, list and tuple classes. int slice str list tuple The formal syntax makes no special provision for negative indices in sequences. However, built-in sequences all provide a getitem() method that interprets negative indices by adding the length of the sequence to the index so that, for example, x[-1] selects the last item of x. The resulting value must be a nonnegative integer less than the number of items in the sequence, and the subscription selects the item whose index is that value (counting from zero). Since the support for negative indices and slicing occurs in the object’s getitem() method, subclasses overriding this method will need to explicitly add that support. __getitem__() x[-1] x __getitem__() A string is a special kind of sequence whose items are characters. A character is not a separate data type but a string of exactly one character. string ### 6. 3. 3. Slicings¶ A slicing selects a range of items in a sequence object (e. g. , a string, tuple or list). Slicings may be used as expressions or as targets in assignment or del statements. The syntax for a slicing: del slicing ::= primary "[" slice_list "]" slice_list ::= slice_item ("," slice_item)* [","] slice_item ::= expression | proper_slice proper_slice ::= [lower_bound] ":" [upper_bound] [ ":" [stride] ] lower_bound ::= expression upper_bound ::= expression stride ::= expression primary slice_list slice_item slice_item expression proper_slice lower_bound upper_bound stride expression expression expression There is ambiguity in the formal syntax here: anything that looks like an expression list also looks like a slice list, so any subscription can be interpreted as a slicing.