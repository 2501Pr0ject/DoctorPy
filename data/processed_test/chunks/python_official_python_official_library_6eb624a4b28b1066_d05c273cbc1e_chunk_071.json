{
  "chunk_id": "python_official_python_official_library_6eb624a4b28b1066_d05c273cbc1e_chunk_071",
  "original_doc_id": "python_official_python_official_library_6eb624a4b28b1066_d05c273cbc1e",
  "content": "if 2006 < year: dststart, dstend = DSTSTART_2007, DSTEND_2007 elif 1986 < year < 2007: dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006 elif 1966 < year < 1987: dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986 else: return (datetime(year, 1, 1), ) * 2 start = first_sunday_on_or_after(dststart. replace(year=year)) end = first_sunday_on_or_after(dstend. replace(year=year)) return start, end class USTimeZone(tzinfo): def __init__(self, hours, reprname, stdname, dstname): self. stdoffset = timedelta(hours=hours) self. reprname = reprname self. stdname = stdname self. dstname = dstname def __repr__(self): return self. reprname def tzname(self, dt): if self. dst(dt): return self. dstname else: return self. stdname def utcoffset(self, dt): return self. stdoffset + self. dst(dt) def dst(self, dt): if dt is None or dt. tzinfo is None: # An exception may be sensible here, in one or both cases. # It depends on how you want to treat them. The default # fromutc() implementation (called by the default astimezone() # implementation) passes a datetime with dt. tzinfo is self. return ZERO assert dt. tzinfo is self start, end = us_dst_range(dt. year) # Can't compare naive to aware objects, so strip the timezone from # dt first. dt = dt. replace(tzinfo=None) if start + HOUR <= dt < end - HOUR: # DST is in effect. return HOUR if end - HOUR <= dt < end: # Fold (an ambiguous hour): use dt. fold to disambiguate. return ZERO if dt. fold else HOUR if start <= dt < start + HOUR: # Gap (a non-existent hour): reverse the fold rule. return HOUR if dt. fold else ZERO # DST is off. return ZERO def fromutc(self, dt): assert dt. tzinfo is self start, end = us_dst_range(dt. year) start = start.",
  "title": "datetime â€” Basic date and time types.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 71,
  "start_char": 129611,
  "end_char": 131314,
  "token_count": 497,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_6eb624a4b28b1066.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:01.448000"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_6eb624a4b28b1066_d05c273cbc1e_chunk_071.txt"
}