" # Use functions that consume iterators at C speed. if n is None: deque(iterator, maxlen=0) else: next(islice(iterator, n, n), None) def nth(iterable, n, default=None): "Returns the nth item or a default value. " return next(islice(iterable, n, None), default) def quantify(iterable, predicate=bool): "Given a predicate that returns True or False, count the True results. " return sum(map(predicate, iterable)) def first_true(iterable, default=False, predicate=None): "Returns the first true value or the *default* if there is no true value. " # first_true([a,b,c], x) → a or b or c or x # first_true([a,b], x, f) → a if f(a) else b if f(b) else x return next(filter(predicate, iterable), default) def all_equal(iterable, key=None): "Returns True if all the elements are equal to each other. " # all_equal('4٤௪౪໔', key=int) → True return len(take(2, groupby(iterable, key))) <= 1 def unique_justseen(iterable, key=None): "Yield unique elements, preserving order. Remember only the element just seen. " # unique_justseen('AAAABBBCCDAABBB') → A B C D A B # unique_justseen('ABBcCAD', str. casefold) → A B c A D if key is None: return map(itemgetter(0), groupby(iterable)) return map(next, map(itemgetter(1), groupby(iterable, key))) def unique_everseen(iterable, key=None): "Yield unique elements, preserving order. Remember all elements ever seen. " # unique_everseen('AAAABBBCCDAABBB') → A B C D # unique_everseen('ABBcCAD', str. casefold) → A B c D seen = set() if key is None: for element in filterfalse(seen. __contains__, iterable): seen. add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen. add(k) yield element def unique(iterable, key=None, reverse=False): "Yield unique elements in sorted order. Supports unhashable inputs.