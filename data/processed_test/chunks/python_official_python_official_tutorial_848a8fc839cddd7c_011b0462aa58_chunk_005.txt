You can also define a specific position for attributes in patterns by setting the match_args special attribute in your classes. If it’s set to (“x”, “y”), the following patterns are all equivalent (and all bind the y attribute to the var variable): __match_args__ y var Point(1, var) Point(1, y=var) Point(x=1, y=var) Point(y=var, x=1) A recommended way to read patterns is to look at them as an extended form of what you would put on the left of an assignment, to understand which variables would be set to what. Only the standalone names (like var above) are assigned to by a match statement. Dotted names (like foo. bar), attribute names (the x= and y= above) or class names (recognized by the “(…)” next to them like Point above) are never assigned to. var foo. bar x= y= Point Patterns can be arbitrarily nested. For example, if we have a short list of Points, with match_args added, we could match it like this: __match_args__ class Point: __match_args__ = ('x', 'y') def __init__(self, x, y): self. x = x self. y = y match points: case []: print("No points") case [Point(0, 0)]: print("The origin") case [Point(x, y)]: print(f"Single point {x}, {y}") case [Point(0, y1), Point(0, y2)]: print(f"Two on the Y axis at {y1}, {y2}") case _: print("Something else") We can add an if clause to a pattern, known as a “guard”. If the guard is false, match goes on to try the next case block. Note that value capture happens before the guard is evaluated: if match match point: case Point(x, y) if x == y: print(f"Y=X at {x}") case Point(x, y): print(f"Not on the diagonal") Several other key features of this statement: Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences. An important exception is that they don’t match iterators or strings. Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences.