{
  "chunk_id": "python_official_python_official_library_0a70a89a6fb229e9_972eb7e87b87_chunk_004",
  "original_doc_id": "python_official_python_official_library_0a70a89a6fb229e9_972eb7e87b87",
  "content": "However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling format(), the normal formatting logic is bypassed. __format__() __format__() Three conversion flags are currently supported: '. s' which calls str() on the value, '. r' which calls repr() and '. a' which calls ascii(). '. s' str() '. r' repr() '. a' ascii() Some examples: \"Harold's a clever {0. s}\" # Calls str() on the argument first \"Bring out the holy {name. r}\" # Calls repr() on the argument first \"More {. a}\" # Calls ascii() on the argument first The format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec. Most built-in types support a common formatting mini-language, which is described in the next section. A format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified. See the Format examples section for some examples. ### Format Specification Mini-Language¶ “Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in format() function. Each formattable type may define how the format specification is to be interpreted. format() Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called str() on the value. A non-empty format specification typically modifies the result. str() The general form of a standard format specifier is: format_spec ::= [options][width][grouping][\".",
  "title": "string — Common string operations.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 4,
  "start_char": 9117,
  "end_char": 11396,
  "token_count": 450,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_0a70a89a6fb229e9.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:09.216317"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_0a70a89a6fb229e9_972eb7e87b87_chunk_004.txt"
}