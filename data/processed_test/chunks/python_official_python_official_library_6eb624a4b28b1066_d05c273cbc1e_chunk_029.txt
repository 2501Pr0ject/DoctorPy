timetuple() >>> for it in tt:. print(it). 2006 # year 11 # month 21 # day 16 # hour 30 # minute 0 # second 1 # weekday (0 = Monday) 325 # number of days since 1st January -1 # dst - method tzinfo. dst() returned None >>> # Date in ISO format >>> ic = dt. isocalendar() >>> for it in ic:. print(it). 2006 # ISO year 47 # ISO week 2 # ISO weekday >>> # Formatting a datetime >>> dt. strftime("%A, %d. %B %Y %I:%M%p") 'Tuesday, 21. November 2006 04:30PM' >>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}. '. format(dt, "day", "month", "time") 'The day is 21, the month is November, the time is 04:30PM. ' The example below defines a tzinfo subclass capturing time zone information for Kabul, Afghanistan, which used +4 UTC until 1945 and then +4:30 UTC thereafter: tzinfo from datetime import timedelta, datetime, tzinfo, timezone class KabulTz(tzinfo): # Kabul used +4 until 1945, when they moved to +4:30 UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone. utc) def utcoffset(self, dt): if dt. year < 1945: return timedelta(hours=4) elif (1945, 1, 1, 0, 0) <= dt. timetuple()[:5] < (1945, 1, 1, 0, 30): # An ambiguous ("imaginary") half-hour range representing # a 'fold' in time due to the shift from +4 to +4:30. # If dt falls in the imaginary range, use fold to decide how # to resolve. See PEP495. return timedelta(hours=4, minutes=(30 if dt. fold else 0)) else: return timedelta(hours=4, minutes=30) def fromutc(self, dt): # Follow same validations as in datetime.