days // 365 10 >>> nine_years = ten_years - year >>> nine_years datetime. timedelta(days=3285) >>> three_years = nine_years // 3 >>> three_years, three_years. days // 365 (datetime. timedelta(days=1095), 3) ## date Objects¶ date A date object represents a date (year, month and day) in an idealized calendar, the current Gregorian calendar indefinitely extended in both directions. date January 1 of year 1 is called day number 1, January 2 of year 1 is called day number 2, and so on. [2] All arguments are required. Arguments must be integers, in the following ranges: MINYEAR <= year <= MAXYEAR MINYEAR <= year <= MAXYEAR MINYEAR <= year <= MAXYEAR 1 <= month <= 12 1 <= month <= 12 1 <= month <= 12 1 <= day <= number of days in the given month and year 1 <= day <= number of days in the given month and year 1 <= day <= number of days in the given month and year If an argument outside those ranges is given, ValueError is raised. ValueError Other constructors, all class methods: Return the current local date. This is equivalent to date. fromtimestamp(time. time()). date. fromtimestamp(time. time()) Return the local date corresponding to the POSIX timestamp, such as is returned by time. time(). time. time() This may raise OverflowError, if the timestamp is out of the range of values supported by the platform C localtime() function, and OSError on localtime() failure. It’s common for this to be restricted to years from 1970 through 2038. Note that on non-POSIX systems that include leap seconds in their notion of a timestamp, leap seconds are ignored by fromtimestamp(). OverflowError localtime() OSError localtime() fromtimestamp() Changed in version 3. 3: Raise OverflowError instead of ValueError if the timestamp is out of the range of values supported by the platform C localtime() function. Raise OSError instead of ValueError on localtime() failure. OverflowError ValueError localtime() OSError ValueError localtime() Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 <= ordinal <= date. max. toordinal(). For any date d, date. fromordinal(d. toordinal()) == d.