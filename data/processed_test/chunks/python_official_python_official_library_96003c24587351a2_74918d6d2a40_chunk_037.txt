Its output is the same as regular zip(): >>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True)) [('a', 1), ('b', 2), ('c', 3)] Unlike the default behavior, it raises a ValueError if one iterable is exhausted before the others: >>> for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):. print(item). (0, 'fee') (1, 'fi') (2, 'fo') Traceback (most recent call last):. ValueError: zip() argument 2 is longer than argument 1 Without the strict=True argument, any bug that results in iterables of different lengths will be silenced, possibly manifesting as a hard-to-find bug in another part of the program. zip() is often used in cases where the iterables are assumed to be of equal length. In such cases, itâ€™s recommended to use the strict=True option. Its output is the same as regular zip(): zip() strict=True zip() >>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True)) [('a', 1), ('b', 2), ('c', 3)] Unlike the default behavior, it raises a ValueError if one iterable is exhausted before the others: ValueError >>> for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):. print(item). (0, 'fee') (1, 'fi') (2, 'fo') Traceback (most recent call last):. ValueError: zip() argument 2 is longer than argument 1 Without the strict=True argument, any bug that results in iterables of different lengths will be silenced, possibly manifesting as a hard-to-find bug in another part of the program. strict=True Shorter iterables can be padded with a constant value to make all the iterables have the same length. This is done by itertools. zip_longest(). Shorter iterables can be padded with a constant value to make all the iterables have the same length. This is done by itertools. zip_longest(). itertools. zip_longest() Edge cases: With a single iterable argument, zip() returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.