\w+ \w [A-Za-z] é ç é LOCALE \w \w+ (^ and $ haven’t been explained yet; they’ll be introduced in section More Metacharacters. ) ^ $ Usually ^ matches only at the beginning of the string, and $ matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, ^ matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the $ metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline). ^ $ ^ $ Makes the '. ' special character match any character at all, including a newline; without this flag, '. ' will match anything except a newline. '. ' '. ' Make \w, \W, \b, \B, \s and \S perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns. \w \W \b \B \s \S This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a '#' that’s neither in a character class or preceded by an unescaped backslash. '#' For example, here’s a RE that uses re. VERBOSE; see how much easier it is to read. re. VERBOSE charref = re. compile(r""" &[#] # Start of a numeric entity reference ( 0[0-7]+ # Octal form | [0-9]+ # Decimal form | x[0-9a-fA-F]+ # Hexadecimal form ) ; # Trailing semicolon """, re. VERBOSE) Without the verbose setting, the RE would look like this: charref = re.