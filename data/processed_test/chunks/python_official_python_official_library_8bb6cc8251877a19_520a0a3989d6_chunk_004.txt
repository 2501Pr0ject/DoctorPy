print(n, len(pep)) >>> get_pep. cache_info() CacheInfo(hits=3, misses=8, maxsize=32, currsize=8) Example of efficiently computing Fibonacci numbers using a cache to implement a dynamic programming technique: @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) >>> [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] >>> fib. cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) Added in version 3. 2. Changed in version 3. 3: Added the typed option. Changed in version 3. 8: Added the user_function option. Changed in version 3. 9: Added the function cache_parameters() cache_parameters() Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations: The class must define one of lt(), le(), gt(), or ge(). In addition, the class should supply an eq() method. __lt__() __le__() __gt__() __ge__() __eq__() For example: @total_ordering class Student: def _is_valid_operand(self, other): return (hasattr(other, "lastname") and hasattr(other, "firstname")) def __eq__(self, other): if not self. _is_valid_operand(other): return NotImplemented return ((self. lastname. lower(), self. firstname. lower()) == (other. lastname. lower(), other. firstname. lower())) def __lt__(self, other): if not self. _is_valid_operand(other): return NotImplemented return ((self. lastname. lower(), self. firstname. lower()) < (other. lastname. lower(), other. firstname. lower())) Note While this decorator makes it easy to create well behaved totally ordered types, it does come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost.