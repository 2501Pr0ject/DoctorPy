__name__}' object is not subscriptable" ) In Python, all classes are themselves instances of other classes. The class of a class is known as that class’s metaclass, and most classes have the type class as their metaclass. type does not define getitem(), meaning that expressions such as list[int], dict[str, float] and tuple[str, bytes] all result in class_getitem() being called: type type __getitem__() list[int] dict[str, float] tuple[str, bytes] __class_getitem__() >>> # list has class "type" as its metaclass, like most classes: >>> type(list) <class 'type'> >>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes) True >>> # "list[int]" calls "list. __class_getitem__(int)" >>> list[int] list[int] >>> # list. __class_getitem__ returns a GenericAlias object: >>> type(list[int]) <class 'types. GenericAlias'> However, if a class has a custom metaclass that defines getitem(), subscribing the class may result in different behaviour. An example of this can be found in the enum module: __getitem__() enum >>> from enum import Enum >>> class Menu(Enum):. """A breakfast menu""". SPAM = 'spam'. BACON = 'bacon'. >>> # Enum classes have a custom metaclass: >>> type(Menu) <class 'enum. EnumMeta'> >>> # EnumMeta defines __getitem__, >>> # so __class_getitem__ is not called, >>> # and the result is not a GenericAlias object: >>> Menu['SPAM'] <Menu. SPAM: 'spam'> >>> type(Menu['SPAM']) <enum 'Menu'> See also Introducing class_getitem(), and outlining when a subscription results in class_getitem() being called instead of getitem() __class_getitem__() __class_getitem__() __getitem__() ### 3. 3. 6. Emulating callable objects¶ Called when the instance is “called” as a function; if this method is defined, x(arg1, arg2,. ) roughly translates to type(x). call(x, arg1,. ). The object class itself does not provide this method. x(arg1, arg2,. ) type(x). __call__(x, arg1,. ) object ### 3. 3. 7.