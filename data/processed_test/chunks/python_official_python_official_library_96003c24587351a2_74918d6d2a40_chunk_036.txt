locals() Iterate over several iterables in parallel, producing tuples with an item from each one. Example: >>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):. print(item). (1, 'sugar') (2, 'spice') (3, 'everything nice') More formally: zip() returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument iterables. zip() Another way to think of zip() is that it turns rows into columns, and columns into rows. This is similar to transposing a matrix. zip() zip() is lazy: The elements won’t be processed until the iterable is iterated on, e. g. by a for loop or by wrapping in a list. zip() for list One thing to consider is that the iterables passed to zip() could have different lengths; sometimes by design, and sometimes because of a bug in the code that prepared these iterables. Python offers three different approaches to dealing with this issue: zip() By default, zip() stops when the shortest iterable is exhausted. It will ignore the remaining items in the longer iterables, cutting off the result to the length of the shortest iterable: >>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum'])) [(0, 'fee'), (1, 'fi'), (2, 'fo')] By default, zip() stops when the shortest iterable is exhausted. It will ignore the remaining items in the longer iterables, cutting off the result to the length of the shortest iterable: zip() >>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum'])) [(0, 'fee'), (1, 'fi'), (2, 'fo')] zip() is often used in cases where the iterables are assumed to be of equal length. In such cases, it’s recommended to use the strict=True option.