__aiter__(iter) running = True while running: try: TARGET = await type(iter). __anext__(iter) except StopAsyncIteration: running = False else: SUITE else: SUITE2 See also aiter() and anext() for details. __aiter__() __anext__() It is a SyntaxError to use an async for statement outside the body of a coroutine function. SyntaxError async for ### 8. 9. 3. The async with statement¶ async with async_with_stmt ::= "async" with_stmt with_stmt An asynchronous context manager is a context manager that is able to suspend execution in its enter and exit methods. The following code: async with EXPRESSION as TARGET: SUITE is semantically equivalent to: manager = (EXPRESSION) aenter = type(manager). __aenter__ aexit = type(manager). __aexit__ value = await aenter(manager) hit_except = False try: TARGET = value SUITE except: hit_except = True if not await aexit(manager, *sys. exc_info()): raise finally: if not hit_except: await aexit(manager, None, None, None) See also aenter() and aexit() for details. __aenter__() __aexit__() It is a SyntaxError to use an async with statement outside the body of a coroutine function. SyntaxError async with See also The proposal that made coroutines a proper standalone concept in Python, and added supporting syntax. ## 8. 10. Type parameter lists¶ Added in version 3. 12. Changed in version 3. 13: Support for default values was added (see PEP 696). type_params ::= "[" type_param ("," type_param)* "]" type_param ::= typevar | typevartuple | paramspec typevar ::= identifier (":" expression). ("=" expression). typevartuple ::= "*" identifier ("=" expression). paramspec ::= "**" identifier ("=" expression). type_param type_param typevar typevartuple paramspec identifier expression expression identifier expression identifier expression Functions (including coroutines), classes and type aliases may contain a type parameter list: def maxT -> T:. async def amaxT -> T:. class Bag[T]: def __iter__(self) -> Iterator[T]:. def add(self, arg: T) -> None:.