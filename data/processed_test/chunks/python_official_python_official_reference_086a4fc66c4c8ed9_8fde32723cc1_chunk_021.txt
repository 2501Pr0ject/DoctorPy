baz bound as baz from foo import attr # foo imported and foo. attr bound as attr '*' import __all__ __all__ __all__ '_' __all__ from module import * SyntaxError from from. import mod pkg pkg. mod from. subpkg2 import mod pkg. subpkg1 pkg. subpkg2. mod importlib. import_module() import module filename sys. path sys. meta_path sys. path_hooks future_stmt ::= "from" "__future__" "import" feature ["as" identifier] ("," feature ["as" identifier])* | "from" "__future__" "import" "(" feature ["as" identifier] ("," feature ["as" identifier])* [","] ")" feature ::= identifier feature identifier feature identifier feature identifier feature identifier identifier annotations absolute_import division generators generator_stop unicode_literals print_function nested_scopes with_statement __future__ import __future__ [as name] exec() compile() M compile() -i global global_stmt ::= "global" identifier ("," identifier)* identifier identifier global global global SyntaxError global global global exec() global eval() compile() nonlocal nonlocal_stmt ::= "nonlocal" identifier ("," identifier)* identifier identifier nonlocal SyntaxError nonlocal SyntaxError nonlocal nonlocal global type type_stmt ::= 'type' identifier [type_params] "=" expression identifier type_params expression type typing. TypeAliasType type Point = tuple[float, float] annotation-def VALUE_OF_Point(): return tuple[float, float] Point = typing. TypeAliasType("Point", VALUE_OF_Point()) annotation-def __value__ type type assert pass del return yield raise break continue import global nonlocal type.