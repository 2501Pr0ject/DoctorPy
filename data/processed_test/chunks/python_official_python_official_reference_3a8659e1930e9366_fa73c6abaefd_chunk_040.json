{
  "chunk_id": "python_official_python_official_reference_3a8659e1930e9366_fa73c6abaefd_chunk_040",
  "original_doc_id": "python_official_python_official_reference_3a8659e1930e9366_fa73c6abaefd",
  "content": "The most derived metaclass is one which is a subtype of all of these candidate metaclasses. If none of the candidate metaclasses meets that criterion, then the class definition will fail with TypeError. type(cls) TypeError #### 3. 3. 3. 4. Preparing the class namespace¶ Once the appropriate metaclass has been identified, then the class namespace is prepared. If the metaclass has a prepare attribute, it is called as namespace = metaclass. prepare(name, bases, kwds) (where the additional keyword arguments, if any, come from the class definition). The prepare method should be implemented as a classmethod. The namespace returned by prepare is passed in to new, but when the final class object is created the namespace is copied into a new dict. __prepare__ namespace = metaclass. __prepare__(name, bases, **kwds) __prepare__ classmethod __prepare__ __new__ dict If the metaclass has no prepare attribute, then the class namespace is initialised as an empty ordered mapping. __prepare__ See also Introduced the prepare namespace hook __prepare__ #### 3. 3. 3. 5. Executing the class body¶ The class body is executed (approximately) as exec(body, globals(), namespace). The key difference from a normal call to exec() is that lexical scoping allows the class body (including any methods) to reference names from the current and outer scopes when the class definition occurs inside a function. exec(body, globals(), namespace) exec() However, even when the class definition occurs inside the function, methods defined inside the class still cannot see names defined at the class scope. Class variables must be accessed through the first parameter of instance or class methods, or through the implicit lexically scoped class reference described in the next section. __class__ #### 3. 3. 3. 6. Creating the class object¶ Once the class namespace has been populated by executing the class body, the class object is created by calling metaclass(name, bases, namespace, kwds) (the additional keywords passed here are the same as those passed to prepare). metaclass(name, bases, namespace, **kwds) __prepare__ This class object is the one that will be referenced by the zero-argument form of super(). class is an implicit closure reference created by the compiler if any methods in a class body refer to either class or super.",
  "title": "3. Data model.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 40,
  "start_char": 92038,
  "end_char": 94359,
  "token_count": 494,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_3a8659e1930e9366.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:56:42.730550"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_3a8659e1930e9366_fa73c6abaefd_chunk_040.txt"
}