__args__ (<class 'str'>, list[int]) __args__ >>> from typing import TypeVar >>> T = TypeVar('T') >>> list[T]. __parameters__ (~T,) GenericAlias typing. ParamSpec __parameters__ typing. ParamSpec * TypeVarTuple __class_getitem__() typing. Generic | typing. Union X | Y typing. Union[X, Y] int float def square(number: int | float) -> int | float: return number ** 2 | int | "Foo" "Foo" "int | Foo" (int | str) | float == int | str | float int | str | int == int | str int | str == str | int typing. Union int | str == typing. Union[int, str] None str | None == typing. Optional[str] isinstance() issubclass() >>> isinstance("", int | str) True >>> isinstance(1, int | list[int]) # short-circuit evaluation True >>> isinstance([1], int | list[int]) Traceback (most recent call last):. TypeError: isinstance() argument 2 cannot be a parameterized generic types. UnionType isinstance() >>> import types >>> isinstance(int | str, types. UnionType) True >>> types. UnionType() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: cannot create 'types. UnionType' instances __or__() X | Y __or__() >>> class M(type):. def __or__(self, other):. return "Hello". >>> class C(metaclass=M):. pass. >>> C | int 'Hello' >>> int | C int | C X | Y m. name import import foo __dict__ __dict__ m. __dict__['a'] = 1 m. a 1 m. __dict__ = {} __dict__ <module 'sys' (built-in)> <module 'os' from '/usr/local/lib/pythonX. Y/os. pyc'> func(argument-list) append() self m. __self__ m. __func__ m(arg-1, arg-2,. , arg-n) m. __func__(m. __self__, arg-1, arg-2,. , arg-n) method. __func__ AttributeError >>> class C:. def method(self):. pass. >>> c = C() >>> c. method.