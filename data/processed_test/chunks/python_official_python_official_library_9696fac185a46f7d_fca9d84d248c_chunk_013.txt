A RuntimeError may be raised when simultaneously using iterators returned by the same tee() call, even if the original iterable is threadsafe. tee RuntimeError tee() This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored). In general, if one iterator uses most or all of the data before another iterator starts, it is faster to use list() instead of tee(). list() tee() Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. If not specified, fillvalue defaults to None. None Iteration continues until the longest iterable is exhausted. Roughly equivalent to: def zip_longest(*iterables, fillvalue=None): # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D- iterators = list(map(iter, iterables)) num_active = len(iterators) if not num_active: return while True: values = [] for i, iterator in enumerate(iterators): try: value = next(iterator) except StopIteration: num_active -= 1 if not num_active: return iterators[i] = repeat(fillvalue) value = fillvalue values. append(value) yield tuple(values) If one of the iterables is potentially infinite, then the zip_longest() function should be wrapped with something that limits the number of calls (for example islice() or takewhile()). zip_longest() islice() takewhile() ## Itertools Recipes¶ This section shows recipes for creating an extended toolset using the existing itertools as building blocks. The primary purpose of the itertools recipes is educational. The recipes show various ways of thinking about individual tools — for example, that chain. from_iterable is related to the concept of flattening. The recipes also give ideas about ways that the tools can be combined — for example, how starmap() and repeat() can work together. The recipes also show patterns for using itertools with the operator and collections modules as well as with the built-in itertools such as map(), filter(), reversed(), and enumerate(). chain. from_iterable starmap() repeat() operator collections map() filter() reversed() enumerate() A secondary purpose of the recipes is to serve as an incubator. The accumulate(), compress(), and pairwise() itertools started out as recipes.