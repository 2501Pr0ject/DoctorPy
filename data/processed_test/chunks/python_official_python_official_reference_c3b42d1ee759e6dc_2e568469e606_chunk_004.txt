This includes only type parameters, as no other syntactic elements that can appear within annotation scopes can introduce new names. nonlocal While annotation scopes have an internal name, that name is not reflected in the qualified name of objects defined within the scope. Instead, the qualname of such objects is as if the object were defined in the enclosing scope. While annotation scopes have an internal name, that name is not reflected in the qualified name of objects defined within the scope. Instead, the qualname of such objects is as if the object were defined in the enclosing scope. __qualname__ Added in version 3. 12: Annotation scopes were introduced in Python 3. 12 as part of PEP 695. Changed in version 3. 13: Annotation scopes are also used for type parameter defaults, as introduced by PEP 696. ### 4. 2. 4. Lazy evaluationÂ¶ The values of type aliases created through the type statement are lazily evaluated. The same applies to the bounds, constraints, and default values of type variables created through the type parameter syntax. This means that they are not evaluated when the type alias or type variable is created. Instead, they are only evaluated when doing so is necessary to resolve an attribute access. type Example: >>> type Alias = 1/0 >>> Alias. __value__ Traceback (most recent call last):. ZeroDivisionError: division by zero >>> def func[T: 1/0](): pass >>> T = func. __type_params__[0] >>> T. __bound__ Traceback (most recent call last):. ZeroDivisionError: division by zero Here the exception is raised only when the value attribute of the type alias or the bound attribute of the type variable is accessed. __value__ __bound__ This behavior is primarily useful for references to types that have not yet been defined when the type alias or type variable is created. For example, lazy evaluation enables creation of mutually recursive type aliases: from typing import Literal type SimpleExpr = int | Parenthesized type Parenthesized = tuple[Literal["("], Expr, Literal[")"]] type Expr = SimpleExpr | tuple[SimpleExpr, Literal["+", "-"], Expr] Lazily evaluated values are evaluated in annotation scope, which means that names that appear inside the lazily evaluated value are looked up as if they were used in the immediately enclosing scope. Added in version 3. 12. ### 4. 2.