{
  "chunk_id": "python_official_python_official_reference_c3b42d1ee759e6dc_2e568469e606_chunk_005",
  "original_doc_id": "python_official_python_official_reference_c3b42d1ee759e6dc_2e568469e606",
  "content": "5. Builtins and restricted execution¶ CPython implementation detail: Users should not touch builtins; it is strictly an implementation detail. Users wanting to override values in the builtins namespace should import the builtins module and modify its attributes appropriately. __builtins__ import builtins The builtins namespace associated with the execution of a code block is actually found by looking up the name builtins in its global namespace; this should be a dictionary or a module (in the latter case the module’s dictionary is used). By default, when in the main module, builtins is the built-in module builtins; when in any other module, builtins is an alias for the dictionary of the builtins module itself. __builtins__ __main__ __builtins__ builtins __builtins__ builtins ### 4. 2. 6. Interaction with dynamic features¶ Name resolution of free variables occurs at runtime, not at compile time. This means that the following code will print 42: i = 10 def f(): print(i) i = 42 f() The eval() and exec() functions do not have access to the full environment for resolving names. Names may be resolved in the local and global namespaces of the caller. Free variables are not resolved in the nearest enclosing namespace, but in the global namespace. [1] The exec() and eval() functions have optional arguments to override the global and local namespace. If only one namespace is specified, it is used for both. eval() exec() exec() eval() ## 4. 3. Exceptions¶ Exceptions are a means of breaking out of the normal flow of control of a code block in order to handle errors or other exceptional conditions. An exception is raised at the point where the error is detected; it may be handled by the surrounding code block or by any code block that directly or indirectly invoked the code block where the error occurred. The Python interpreter raises an exception when it detects a run-time error (such as division by zero). A Python program can also explicitly raise an exception with the raise statement. Exception handlers are specified with the try … except statement. The finally clause of such a statement can be used to specify cleanup code which does not handle the exception, but is executed whether an exception occurred or not in the preceding code.",
  "title": "4. Execution model.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 5,
  "start_char": 12275,
  "end_char": 14538,
  "token_count": 466,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_c3b42d1ee759e6dc.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:33.213081"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_c3b42d1ee759e6dc_2e568469e606_chunk_005.txt"
}