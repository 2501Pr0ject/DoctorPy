{
  "chunk_id": "python_official_python_official_library_bfa9edd59fb6bc20_f9e9b8d89b43_chunk_044",
  "original_doc_id": "python_official_python_official_library_bfa9edd59fb6bc20_f9e9b8d89b43",
  "content": "r While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that 0 <= x < 256 (attempts to violate this restriction will trigger ValueError). This is done deliberately to emphasise that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption). 0 <= x < 256 ValueError In addition to the literal forms, bytes objects can be created in a number of other ways: A zero-filled bytes object of a specified length: bytes(10) A zero-filled bytes object of a specified length: bytes(10) bytes(10) From an iterable of integers: bytes(range(20)) From an iterable of integers: bytes(range(20)) bytes(range(20)) Copying existing binary data via the buffer protocol: bytes(obj) Copying existing binary data via the buffer protocol: bytes(obj) bytes(obj) Also see the bytes built-in. Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data. Accordingly, the bytes type has an additional class method to read data in that format: This bytes class method returns a bytes object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored. bytes >>> bytes. fromhex('2Ef0 F1f2 ') b'. \\xf0\\xf1\\xf2' Changed in version 3. 7: bytes. fromhex() now skips all ASCII whitespace in the string, not just spaces. bytes. fromhex() A reverse conversion function exists to transform a bytes object into its hexadecimal representation. Return a string object containing two hexadecimal digits for each byte in the instance. >>> b'\\xf0\\xf1\\xf2'. hex() 'f0f1f2' If you want to make the hex string easier to read, you can specify a single character separator sep parameter to include in the output. By default, this separator will be included between each byte. A second optional bytes_per_sep parameter controls the spacing. Positive values calculate the separator position from the right, negative values from the left. >>> value = b'\\xf0\\xf1\\xf2' >>> value.",
  "title": "Built-in Types.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 44,
  "start_char": 89280,
  "end_char": 91639,
  "token_count": 492,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_bfa9edd59fb6bc20.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:56:56.219495"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_bfa9edd59fb6bc20_f9e9b8d89b43_chunk_044.txt"
}