{
  "chunk_id": "python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30_chunk_027",
  "original_doc_id": "python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30",
  "content": "A parenthesized tuple of expressions after the colon indicates a set of constraints (e. g. T: (str, bytes)). Each member of the tuple should be a type (again, this is not enforced at runtime). Constrained type variables can only take on one of the types in the list of constraints. typing. TypeVar : T: int typing. TypeVar T: (str, bytes) For typing. TypeVars declared using the type parameter list syntax, the bound and constraints are not evaluated when the generic object is created, but only when the value is explicitly accessed through the attributes bound and constraints. To accomplish this, the bounds or constraints are evaluated in a separate annotation scope. typing. TypeVar __bound__ __constraints__ typing. TypeVarTuples and typing. ParamSpecs cannot have bounds or constraints. typing. TypeVarTuple typing. ParamSpec All three flavors of type parameters can also have a default value, which is used when the type parameter is not explicitly provided. This is added by appending a single equals sign (=) followed by an expression. Like the bounds and constraints of type variables, the default value is not evaluated when the object is created, but only when the type parameter’s default attribute is accessed. To this end, the default value is evaluated in a separate annotation scope. If no default value is specified for a type parameter, the default attribute is set to the special sentinel object typing. NoDefault. = __default__ __default__ typing. NoDefault The following example indicates the full set of allowed type parameter declarations: def overly_generic SimpleTypeVar, TypeVarWithDefault = int, TypeVarWithBound: int, TypeVarWithConstraints: (str, bytes), *SimpleTypeVarTuple = (int, float), **SimpleParamSpec = (str, bytearray), :. ### 8. 10. 1. Generic functions¶ Generic functions are declared as follows: def funcT:. This syntax is equivalent to: annotation-def TYPE_PARAMS_OF_func(): T = typing. TypeVar(\"T\") def func(arg: T):. func. __type_params__ = (T,) return func func = TYPE_PARAMS_OF_func() Here annotation-def indicates an annotation scope, which is not actually bound to any name at runtime. (One other liberty is taken in the translation: the syntax does not go through attribute access on the typing module, but creates an instance of typing. TypeVar directly. ) annotation-def typing typing.",
  "title": "8. Compound statements.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 27,
  "start_char": 62895,
  "end_char": 65233,
  "token_count": 501,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_ec1b46183acd657b.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:27.389169"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_ec1b46183acd657b_b5c0645e7b30_chunk_027.txt"
}