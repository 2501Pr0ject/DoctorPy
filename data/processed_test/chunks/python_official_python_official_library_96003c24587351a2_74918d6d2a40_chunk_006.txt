5j) >>> complex('-Infinity+NaNj') (-inf+nanj) >>> complex(1. 23) (1. 23+0j) >>> complex(imag=-4. 5) -4. 5j >>> complex(-1. 23, 4. 5) (-1. 23+4. 5j) If the argument is a string, it must contain either a real part (in the same format as for float()) or an imaginary part (in the same format but with a 'j' or 'J' suffix), or both real and imaginary parts (the sign of the imaginary part is mandatory in this case). The string can optionally be surrounded by whitespaces and the round parentheses '(' and ')', which are ignored. The string must not contain whitespace between '+', '-', the 'j' or 'J' suffix, and the decimal number. For example, complex('1+2j') is fine, but complex('1 + 2j') raises ValueError. More precisely, the input must conform to the complexvalue production rule in the following grammar, after parentheses and leading and trailing whitespace characters are removed: float() 'j' 'J' '(' ')' '+' '-' 'j' 'J' complex('1+2j') complex('1 + 2j') ValueError complexvalue complexvalue ::= floatvalue | floatvalue ("j" | "J") | floatvalue sign absfloatvalue ("j" | "J") floatvalue floatvalue floatvalue sign absfloatvalue If the argument is a number, the constructor serves as a numeric conversion like int and float. For a general Python object x, complex(x) delegates to x. complex(). If complex() is not defined then it falls back to float(). If float() is not defined then it falls back to index(). int float x complex(x) x. __complex__() __complex__() __float__() __float__() __index__() If two arguments are provided or keyword arguments are used, each argument may be any numeric type (including complex). If both arguments are real numbers, return a complex number with the real component real and the imaginary component imag. If both arguments are complex numbers, return a complex number with the real component real. real-imag. imag and the imaginary component real. imag+imag. real. If one of arguments is a real number, only its real component is used in the above expressions. real.