2. 6. Set types¶ These represent unordered, finite sets of unique, immutable objects. As such, they cannot be indexed by any subscript. However, they can be iterated over, and the built-in function len() returns the number of items in a set. Common uses for sets are fast membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference. len() For set elements, the same immutability rules apply as for dictionary keys. Note that numeric types obey the normal rules for numeric comparison: if two numbers compare equal (e. g. , 1 and 1. 0), only one of them can be contained in a set. 1 1. 0 There are currently two intrinsic set types: These represent a mutable set. They are created by the built-in set() constructor and can be modified afterwards by several methods, such as add(). set() add() These represent an immutable set. They are created by the built-in frozenset() constructor. As a frozenset is immutable and hashable, it can be used again as an element of another set, or as a dictionary key. frozenset() ### 3. 2. 7. Mappings¶ These represent finite sets of objects indexed by arbitrary index sets. The subscript notation a[k] selects the item indexed by k from the mapping a; this can be used in expressions and as the target of assignments or del statements. The built-in function len() returns the number of items in a mapping. a[k] k a del len() There is currently a single intrinsic mapping type: #### 3. 2. 7. 1. Dictionaries¶ These represent finite sets of objects indexed by nearly arbitrary values. The only types of values not acceptable as keys are values containing lists or dictionaries or other mutable types that are compared by value rather than by object identity, the reason being that the efficient implementation of dictionaries requires a key’s hash value to remain constant. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (e. g. , 1 and 1. 0) then they can be used interchangeably to index the same dictionary entry. 1 1. 0 Dictionaries preserve insertion order, meaning that keys will be produced in the same order they were added sequentially over the dictionary.