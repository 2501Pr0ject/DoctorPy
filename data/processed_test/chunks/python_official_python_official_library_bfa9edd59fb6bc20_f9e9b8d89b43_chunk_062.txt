readonly False >>> v[0] = ord(b'z') >>> data bytearray(b'zbcefg') >>> v[1:4] = b'123' >>> data bytearray(b'z123fg') >>> v[2:3] = b'spam' Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: memoryview assignment: lvalue and rvalue have different structures >>> v[2:6] = b'spam' >>> data bytearray(b'z1spam') One-dimensional memoryviews of hashable (read-only) types with formats ‘B’, ‘b’ or ‘c’ are also hashable. The hash is defined as hash(m) == hash(m. tobytes()): hash(m) == hash(m. tobytes()) >>> v = memoryview(b'abcefg') >>> hash(v) == hash(b'abcefg') True >>> hash(v[2:4]) == hash(b'ce') True >>> hash(v[::-2]) == hash(b'abcefg'[::-2]) True Changed in version 3. 3: One-dimensional memoryviews can now be sliced. One-dimensional memoryviews with formats ‘B’, ‘b’ or ‘c’ are now hashable. Changed in version 3. 4: memoryview is now registered automatically with collections. abc. Sequence collections. abc. Sequence Changed in version 3. 5: memoryviews can now be indexed with tuple of integers. memoryview has several methods: memoryview A memoryview and a PEP 3118 exporter are equal if their shapes are equivalent and if all corresponding values are equal when the operands’ respective format codes are interpreted using struct syntax. struct For the subset of struct format strings currently supported by tolist(), v and w are equal if v. tolist() == w. tolist(): struct tolist() v w v. tolist() == w. tolist() >>> import array >>> a = array. array('I', [1, 2, 3, 4, 5]) >>> b = array. array('d', [1. 0, 2. 0, 3. 0, 4. 0, 5. 0]) >>> c = array.