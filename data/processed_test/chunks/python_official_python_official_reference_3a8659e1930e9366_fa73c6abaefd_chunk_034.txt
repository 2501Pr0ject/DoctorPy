__get__() __set__() __delete__() The default behavior for attribute access is to get, set, or delete the attribute from an object’s dictionary. For instance, a. x has a lookup chain starting with a. dict['x'], then type(a). dict['x'], and continuing through the base classes of type(a) excluding metaclasses. a. x a. __dict__['x'] type(a). __dict__['x'] type(a) However, if the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead. Where this occurs in the precedence chain depends on which descriptor methods were defined and how they were called. The starting point for descriptor invocation is a binding, a. x. How the arguments are assembled depends on a: a. x a The simplest and least common call is when user code directly invokes a descriptor method: x. get(a). x. __get__(a) If binding to an object instance, a. x is transformed into the call: type(a). dict['x']. get(a, type(a)). a. x type(a). __dict__['x']. __get__(a, type(a)) If binding to a class, A. x is transformed into the call: A. dict['x']. get(None, A). A. x A. __dict__['x']. __get__(None, A) A dotted lookup such as super(A, a). x searches a. class. mro for a base class B following A and then returns B. dict['x']. get(a, A). If not a descriptor, x is returned unchanged. super(A, a). x a. __class__. __mro__ B A B. __dict__['x']. __get__(a, A) x For instance bindings, the precedence of descriptor invocation depends on which descriptor methods are defined. A descriptor can define any combination of get(), set() and delete(). If it does not define get(), then accessing the attribute will return the descriptor object itself unless there is a value in the object’s instance dictionary. If the descriptor defines set() and/or delete(), it is a data descriptor; if it defines neither, it is a non-data descriptor. Normally, data descriptors define both get() and set(), while non-data descriptors have just the get() method.