__eq__() __hash__() __hash__ = <ParentClass>. __hash__ If a class that does not override eq() wishes to suppress hash support, it should include hash = None in the class definition. A class which defines its own hash() that explicitly raises a TypeError would be incorrectly identified as hashable by an isinstance(obj, collections. abc. Hashable) call. __eq__() __hash__ = None __hash__() TypeError isinstance(obj, collections. abc. Hashable) Note By default, the hash() values of str and bytes objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python. __hash__() This is intended to provide protection against a denial-of-service caused by carefully chosen inputs that exploit the worst case performance of a dict insertion, O(n2) complexity. See  for details. Changing hash values affects the iteration order of sets. Python has never made guarantees about this ordering (and it typically varies between 32-bit and 64-bit builds). See also PYTHONHASHSEED. PYTHONHASHSEED Changed in version 3. 3: Hash randomization is enabled by default. Called to implement truth value testing and the built-in operation bool(); should return False or True. When this method is not defined, len() is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither len() nor bool() (which is true of the object class itself), all its instances are considered true. bool() False True __len__() __len__() __bool__() object ### 3. 3. 2. Customizing attribute access¶ The following methods can be defined to customize the meaning of attribute access (use of, assignment to, or deletion of x. name) for class instances. x. name Called when the default attribute access fails with an AttributeError (either getattribute() raises an AttributeError because name is not an instance attribute or an attribute in the class tree for self; or get() of a name property raises AttributeError). This method should either return the (computed) attribute value or raise an AttributeError exception. The object class itself does not provide this method. AttributeError __getattribute__() AttributeError self __get__() AttributeError AttributeError object Note that if the attribute is found through the normal mechanism, getattr() is not called. (This is an intentional asymmetry between getattr() and setattr().