nbytes 48 Cast 1D/unsigned long to 2D/unsigned long: >>> buf = struct. pack("L"*6, *list(range(6))) >>> x = memoryview(buf) >>> y = x. cast('L', shape=[2,3]) >>> len(y) 2 >>> y. nbytes 48 >>> y. tolist() [[0, 1, 2], [3, 4, 5]] Added in version 3. 3. Changed in version 3. 5: The source format is no longer restricted when casting to a byte view. There are also several readonly attributes available: The underlying object of the memoryview: >>> b = bytearray(b'xyz') >>> m = memoryview(b) >>> m. obj is b True Added in version 3. 3. nbytes == product(shape) * itemsize == len(m. tobytes()). This is the amount of space in bytes that the array would use in a contiguous representation. It is not necessarily equal to len(m): nbytes == product(shape) * itemsize == len(m. tobytes()) len(m) >>> import array >>> a = array. array('i', [1,2,3,4,5]) >>> m = memoryview(a) >>> len(m) 5 >>> m. nbytes 20 >>> y = m[::2] >>> len(y) 3 >>> y. nbytes 12 >>> len(y. tobytes()) 12 Multi-dimensional arrays: >>> import struct >>> buf = struct. pack("d"*12, *[1. 5*x for x in range(12)]) >>> x = memoryview(buf) >>> y = x. cast('d', shape=[3,4]) >>> y. tolist() [[0. 0, 1. 5, 3. 0, 4. 5], [6. 0, 7. 5, 9. 0, 10. 5], [12. 0, 13. 5, 15. 0, 16. 5]] >>> len(y) 3 >>> y. nbytes 96 Added in version 3. 3. A bool indicating whether the memory is read only. A string containing the format (in struct module style) for each element in the view.