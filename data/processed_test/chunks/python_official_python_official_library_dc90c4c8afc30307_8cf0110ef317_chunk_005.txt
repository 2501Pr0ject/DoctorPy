inf, x) ValueError On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Added in version 3. 7. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: trunc() is equivalent to floor() for positive x, and equivalent to ceil() for negative x. If x is not a float, delegates to x. trunc, which should return an Integral value. trunc() floor() ceil() x. __trunc__ Integral For the ceil(), floor(), and modf() functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with abs(x) >= 252 necessarily has no fractional bits. ceil() floor() modf() abs(x) >= 2**52 ## Floating point manipulation functions¶ Return a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, copysign(1. 0, -0. 0) returns -1. 0. copysign(1. 0, -0. 0) Return the mantissa and exponent of x as the pair (m, e). m is a float and e is an integer such that x == m * 2e exactly. If x is zero, returns (0. 0, 0), otherwise 0. 5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way. (m, e) x == m * 2**e (0. 0, 0) 0. 5 <= abs(m) < 1 Note that frexp() has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). frexp() Return True if the values a and b are close to each other and False otherwise. True False Whether or not two values are considered close is determined according to given absolute and relative tolerances.