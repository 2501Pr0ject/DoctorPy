iterable must be a sequence, an iterator, or some other object which supports iteration. The next() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable. __next__() enumerate() >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter'] >>> list(enumerate(seasons)) [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')] >>> list(enumerate(seasons, start=1)) [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] Equivalent to: def enumerate(iterable, start=0): n = start for elem in iterable: yield n, elem n += 1 source (str | code object) – A Python expression. source (str | code object) – A Python expression. str globals (dict | None) – The global namespace (default: None). globals (dict | None) – The global namespace (default: None). dict None None locals (mapping | None) – The local namespace (default: None). locals (mapping | None) – The local namespace (default: None). None None The result of the evaluated expression. Syntax errors are reported as exceptions. Warning This function executes arbitrary code. Calling it with user-supplied input may lead to security vulnerabilities. The expression argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the globals and locals mappings as global and local namespace. If the globals dictionary is present and does not contain a value for the key builtins, a reference to the dictionary of the built-in module builtins is inserted under that key before expression is parsed. That way you can control what builtins are available to the executed code by inserting your own builtins dictionary into globals before passing it to eval(). If the locals mapping is omitted it defaults to the globals dictionary. If both mappings are omitted, the expression is executed with the globals and locals in the environment where eval() is called. Note, eval() will only have access to the nested scopes (non-locals) in the enclosing environment if they are already referenced in the scope that is calling eval() (e. g. via a nonlocal statement).