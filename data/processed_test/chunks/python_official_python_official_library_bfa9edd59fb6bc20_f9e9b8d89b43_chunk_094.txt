byteorder def from_bytes(bytes, byteorder='big', signed=False): if byteorder == 'little': little_ordered = list(bytes) elif byteorder == 'big': little_ordered = list(reversed(bytes)) else: raise ValueError("byteorder must be either 'little' or 'big'") n = sum(b << i*8 for i, b in enumerate(little_ordered)) if signed and little_ordered and (little_ordered[-1] & 0x80): n -= 1 << 8*len(little_ordered) return n byteorder 1 True float. is_integer() numbers. Real OverflowError ValueError True False >>> (-2. 0). is_integer() True >>> (3. 2). is_integer() False 0x p float. hex() float. fromhex() [sign] ['0x'] integer ['. ' fraction] ['p' exponent] sign + - integer fraction exponent float. hex() %a Double. toHexString float. fromhex() 0x3. a7p10 (3 + 10. /16 + 7. /16**2) * 2. 0**10 3740. 0 >>> float. fromhex('0x3. a7p10') 3740. 0 3740. 0 >>> float. hex(3740. 0) '0x1. d380000000000p+11' x y hash(x) == hash(y) x == y __hash__() int float decimal. Decimal fractions. Fraction int fractions. Fraction float decimal. Decimal P P P modulus sys. hash_info P = 2**31 - 1 P = 2**61 - 1 x = m / n n P hash(x) m * invmod(n, P) % P invmod(n, P) n P x = m / n n P m n P hash(x) sys. hash_info. inf x = m / n hash(x) -hash(-x) -1 -2 sys. hash_info. inf -sys. hash_info. inf complex z hash(z. real) + sys. hash_info. imag * hash(z. imag) 2**sys. hash_info. width range(-2**(sys. hash_info. width - 1), 2**(sys. hash_info.