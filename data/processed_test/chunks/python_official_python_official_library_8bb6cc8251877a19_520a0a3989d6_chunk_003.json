{
  "chunk_id": "python_official_python_official_library_8bb6cc8251877a19_520a0a3989d6_chunk_003",
  "original_doc_id": "python_official_python_official_library_8bb6cc8251877a19_520a0a3989d6",
  "content": "In contrast, the tuple arguments ('answer', Decimal(42)) and ('answer', Fraction(42)) are treated as equivalent. Decimal(42) Fraction(42) ('answer', Decimal(42)) ('answer', Fraction(42)) The wrapped function is instrumented with a cache_parameters() function that returns a new dict showing the values for maxsize and typed. This is for information purposes only. Mutating the values has no effect. cache_parameters() dict To help measure the effectiveness of the cache and tune the maxsize parameter, the wrapped function is instrumented with a cache_info() function that returns a named tuple showing hits, misses, maxsize and currsize. cache_info() The decorator also provides a cache_clear() function for clearing or invalidating the cache. cache_clear() The original underlying function is accessible through the wrapped attribute. This is useful for introspection, for bypassing the cache, or for rewrapping the function with a different cache. __wrapped__ The cache keeps references to the arguments and return values until they age out of the cache or until the cache is cleared. If a method is cached, the self instance argument is included in the cache. See How do I cache method calls. self An LRU (least recently used) cache works best when the most recent calls are the best predictors of upcoming calls (for example, the most popular articles on a news server tend to change each day). The cache’s size limit assures that the cache does not grow without bound on long-running processes such as web servers. In general, the LRU cache should only be used when you want to reuse previously computed values. Accordingly, it doesn’t make sense to cache functions with side-effects, functions that need to create distinct mutable objects on each call (such as generators and async functions), or impure functions such as time() or random(). Example of an LRU cache for static web content: @lru_cache(maxsize=32) def get_pep(num): 'Retrieve text of a Python Enhancement Proposal' resource = f' try: with urllib. request. urlopen(resource) as s: return s. read() except urllib. error. HTTPError: return 'Not Found' >>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:. pep = get_pep(n).",
  "title": "functools — Higher-order functions and operations on callable objects.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 3,
  "start_char": 7070,
  "end_char": 9274,
  "token_count": 491,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_8bb6cc8251877a19.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:09.499595"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_8bb6cc8251877a19_520a0a3989d6_chunk_003.txt"
}