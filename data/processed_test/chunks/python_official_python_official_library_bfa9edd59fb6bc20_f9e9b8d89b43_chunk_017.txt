i <= k < j len(s) len(s) None 0 None len(s) The slice of s from i to j with step k is defined as the sequence of items with index x = i + nk such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2k, i+3k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. The slice of s from i to j with step k is defined as the sequence of items with index x = i + nk such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2k, i+3k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. x = i + n*k 0 <= n < (j-i)/k i i+k i+2*k i+3*k len(s) len(s) - 1 None None 1 Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str. join() at the end or else write to an io. StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes. join() or io. BytesIO, or you can do in-place concatenation with a bytearray object.