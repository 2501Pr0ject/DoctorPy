{
  "chunk_id": "python_official_python_official_reference_0a48b6880ef6a9cd_087b11fde119_chunk_019",
  "original_doc_id": "python_official_python_official_reference_0a48b6880ef6a9cd_087b11fde119",
  "content": "0 to a negative power results in a ZeroDivisionError. Raising a negative number to a fractional power results in a complex number. (In earlier versions it raised a ValueError. ) 0. 0 ZeroDivisionError complex ValueError This operation can be customized using the special pow() and rpow() methods. __pow__() __rpow__() ## 6. 6. Unary arithmetic and bitwise operations¶ All unary arithmetic and bitwise operations have the same priority: u_expr ::= power | \"-\" u_expr | \"+\" u_expr | \"~\" u_expr power u_expr u_expr u_expr The unary - (minus) operator yields the negation of its numeric argument; the operation can be overridden with the neg() special method. - __neg__() The unary + (plus) operator yields its numeric argument unchanged; the operation can be overridden with the pos() special method. + __pos__() The unary ~ (invert) operator yields the bitwise inversion of its integer argument. The bitwise inversion of x is defined as -(x+1). It only applies to integral numbers or to custom objects that override the invert() special method. ~ x -(x+1) __invert__() In all three cases, if the argument does not have the proper type, a TypeError exception is raised. TypeError ## 6. 7. Binary arithmetic operations¶ The binary arithmetic operations have the conventional priority levels. Note that some of these operations also apply to certain non-numeric types. Apart from the power operator, there are only two levels, one for multiplicative operators and one for additive operators: m_expr ::= u_expr | m_expr \"*\" u_expr | m_expr \"@\" m_expr | m_expr \"//\" u_expr | m_expr \"/\" u_expr | m_expr \"%\" u_expr a_expr ::= m_expr | a_expr \"+\" m_expr | a_expr \"-\" m_expr u_expr m_expr u_expr m_expr m_expr m_expr u_expr m_expr u_expr m_expr u_expr m_expr a_expr m_expr a_expr m_expr The * (multiplication) operator yields the product of its arguments. The arguments must either both be numbers, or one argument must be an integer and the other must be a sequence. In the former case, the numbers are converted to a common type and then multiplied together. In the latter case, sequence repetition is performed; a negative repetition factor yields an empty sequence. * This operation can be customized using the special mul() and rmul() methods.",
  "title": "6. Expressions.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 19,
  "start_char": 45163,
  "end_char": 47400,
  "token_count": 493,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_0a48b6880ef6a9cd.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:08.587064"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_0a48b6880ef6a9cd_087b11fde119_chunk_019.txt"
}