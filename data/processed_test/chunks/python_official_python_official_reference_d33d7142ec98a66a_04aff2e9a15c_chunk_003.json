{
  "chunk_id": "python_official_python_official_reference_d33d7142ec98a66a_04aff2e9a15c_chunk_003",
  "original_doc_id": "python_official_python_official_reference_d33d7142ec98a66a_04aff2e9a15c",
  "content": "bar. baz ModuleNotFoundError ### 5. 3. 1. The module cache¶ The first place checked during import search is sys. modules. This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So if foo. bar. baz was previously imported, sys. modules will contain entries for foo, foo. bar, and foo. bar. baz. Each key will have as its value the corresponding module object. sys. modules foo. bar. baz sys. modules foo foo. bar foo. bar. baz During import, the module name is looked up in sys. modules and if present, the associated value is the module satisfying the import, and the process completes. However, if the value is None, then a ModuleNotFoundError is raised. If the module name is missing, Python will continue searching for the module. sys. modules None ModuleNotFoundError sys. modules is writable. Deleting a key may not destroy the associated module (as other modules may hold references to it), but it will invalidate the cache entry for the named module, causing Python to search anew for the named module upon its next import. The key can also be assigned to None, forcing the next import of the module to result in a ModuleNotFoundError. sys. modules None ModuleNotFoundError Beware though, as if you keep a reference to the module object, invalidate its cache entry in sys. modules, and then re-import the named module, the two module objects will not be the same. By contrast, importlib. reload() will reuse the same module object, and simply reinitialise the module contents by rerunning the module’s code. sys. modules importlib. reload() ### 5. 3. 2. Finders and loaders¶ If the named module is not found in sys. modules, then Python’s import protocol is invoked to find and load the module. This protocol consists of two conceptual objects, finders and loaders. A finder’s job is to determine whether it can find the named module using whatever strategy it knows about. Objects that implement both of these interfaces are referred to as importers - they return themselves when they find that they can load the requested module. sys. modules Python includes a number of default finders and importers. The first one knows how to locate built-in modules, and the second knows how to locate frozen modules. A third default finder searches an import path for modules.",
  "title": "5. The import system.13.5",
  "section": "python_official",
  "subsection": "reference",
  "chunk_index": 3,
  "start_char": 7226,
  "end_char": 9560,
  "token_count": 493,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_reference_d33d7142ec98a66a.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:39.004579"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_reference_d33d7142ec98a66a_04aff2e9a15c_chunk_003.txt"
}