{
  "chunk_id": "python_official_python_official_library_0a70a89a6fb229e9_972eb7e87b87_chunk_014",
  "original_doc_id": "python_official_python_official_library_0a70a89a6fb229e9_972eb7e87b87",
  "content": "Like substitute(), except that if placeholders are missing from mapping and kwds, instead of raising a KeyError exception, the original placeholder will appear in the resulting string intact. Also, unlike with substitute(), any other appearances of the $ will simply return $ instead of raising ValueError. substitute() KeyError substitute() $ $ ValueError While other exceptions may still occur, this method is called “safe” because it always tries to return a usable string instead of raising an exception. In another sense, safe_substitute() may be anything other than safe, since it will silently ignore malformed templates containing dangling delimiters, unmatched braces, or placeholders that are not valid Python identifiers. safe_substitute() Returns False if the template has invalid placeholders that will cause substitute() to raise ValueError. False substitute() ValueError Added in version 3. 11. Returns a list of the valid identifiers in the template, in the order they first appear, ignoring any invalid identifiers. Added in version 3. 11. Template instances also provide one public data attribute: Template This is the object passed to the constructor’s template argument. In general, you shouldn’t change it, but read-only access is not enforced. Here is an example of how to use a Template: >>> from string import Template >>> s = Template('$who likes $what') >>> s. substitute(who='tim', what='kung pao') 'tim likes kung pao' >>> d = dict(who='tim') >>> Template('Give $who $100'). substitute(d) Traceback (most recent call last):. ValueError: Invalid placeholder in string: line 1, col 11 >>> Template('$who likes $what'). substitute(d) Traceback (most recent call last):. KeyError: 'what' >>> Template('$who likes $what'). safe_substitute(d) 'tim likes $what' Advanced usage: you can derive subclasses of Template to customize the placeholder syntax, delimiter character, or the entire regular expression used to parse template strings. To do this, you can override these class attributes: Template delimiter – This is the literal string describing a placeholder introducing delimiter. The default value is $. Note that this should not be a regular expression, as the implementation will call re. escape() on this string as needed. Note further that you cannot change the delimiter after class creation (i. e. a different delimiter must be set in the subclass’s class namespace). delimiter – This is the literal string describing a placeholder introducing delimiter.",
  "title": "string — Common string operations.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 14,
  "start_char": 28611,
  "end_char": 31100,
  "token_count": 499,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_0a70a89a6fb229e9.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:09.225159"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_0a70a89a6fb229e9_972eb7e87b87_chunk_014.txt"
}