" # all_equal('4٤௪౪໔', key=int) → True return len(take(2, groupby(iterable, key))) <= 1 def unique_justseen(iterable, key=None): "Yield unique elements, preserving order. Remember only the element just seen. " # unique_justseen('AAAABBBCCDAABBB') → A B C D A B # unique_justseen('ABBcCAD', str. casefold) → A B c A D if key is None: return map(itemgetter(0), groupby(iterable)) return map(next, map(itemgetter(1), groupby(iterable, key))) def unique_everseen(iterable, key=None): "Yield unique elements, preserving order. Remember all elements ever seen. " # unique_everseen('AAAABBBCCDAABBB') → A B C D # unique_everseen('ABBcCAD', str. casefold) → A B c D seen = set() if key is None: for element in filterfalse(seen. __contains__, iterable): seen. add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen. add(k) yield element def unique(iterable, key=None, reverse=False): "Yield unique elements in sorted order. Supports unhashable inputs. " # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4] sequenced = sorted(iterable, key=key, reverse=reverse) return unique_justseen(sequenced, key=key) def sliding_window(iterable, n): "Collect data into overlapping fixed-length chunks or blocks. " # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG iterator = iter(iterable) window = deque(islice(iterator, n - 1), maxlen=n) for x in iterator: window. append(x) yield tuple(window) def grouper(iterable, n, *, incomplete='fill', fillvalue=None): "Collect data into non-overlapping fixed-length chunks or blocks.