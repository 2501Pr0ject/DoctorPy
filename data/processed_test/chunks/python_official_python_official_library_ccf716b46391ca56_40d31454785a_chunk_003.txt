For example, aa will match 'aaaa' because the a will match all 4 'a's, but, when the final 'a' is encountered, the expression is backtracked so that in the end the a ends up matching 3 'a's total, and the fourth 'a' is matched by the final 'a'. However, when a+a is used to match 'aaaa', the a+ will match all 4 'a', but when the final 'a' fails to find any more characters to match, the expression cannot be backtracked and will thus fail to match. x+, x++ and x. + are equivalent to (. >x), (. >x+) and (. >x. ) correspondingly. '*' '+' '. ' '+' a*a 'aaaa' a* 'a' 'a' a* 'a' 'a' 'a' a*+a 'aaaa' a*+ 'a' 'a' x*+ x++ x. + (. >x*) (. >x+) (. >x. ) Added in version 3. 11. {m} Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five. a{6} 'a' {m,n} Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible. For example, a{3,5} will match from 3 to 5 'a' characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, a{4,}b will match 'aaaab' or a thousand 'a' characters followed by a 'b', but not 'aaab'. The comma may not be omitted or the modifier would be confused with the previously described form. a{3,5} 'a' a{4,}b 'aaaab' 'a' 'b' 'aaab' {m,n}. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous quantifier.