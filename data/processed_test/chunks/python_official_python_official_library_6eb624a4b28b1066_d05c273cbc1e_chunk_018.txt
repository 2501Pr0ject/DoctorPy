strptime(date_string, format)[0:6])) ValueError is raised if the date_string and format can’t be parsed by time. strptime() or if it returns a value which isn’t a time tuple. See also strftime() and strptime() Behavior and datetime. fromisoformat(). ValueError time. strptime() datetime. fromisoformat() Changed in version 3. 13: If format specifies a day of month without a year a DeprecationWarning is now emitted. This is to avoid a quadrennial leap year bug in code seeking to parse only a month and day as the default year used in absence of one in the format is not a leap year. Such format values may raise an error as of Python 3. 15. The workaround is to always include a year in your format. If parsing date_string values that do not have a year, explicitly add a year that is a leap year before parsing: DeprecationWarning >>> from datetime import datetime >>> date_string = "02/29" >>> when = datetime. strptime(f"{date_string};1984", "%m/%d;%Y") # Avoids leap year bug. >>> when. strftime("%B %d") 'February 29' Class attributes: The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None). datetime datetime(MINYEAR, 1, 1, tzinfo=None) The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None). datetime datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None) The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1). datetime timedelta(microseconds=1) Instance attributes (read-only): Between MINYEAR and MAXYEAR inclusive. MINYEAR MAXYEAR Between 1 and 12 inclusive. Between 1 and the number of days in the given month of the given year. In range(24). range(24) In range(60). range(60) In range(60). range(60) In range(1000000). range(1000000) The object passed as the tzinfo argument to the datetime constructor, or None if none was passed. datetime None In [0, 1].