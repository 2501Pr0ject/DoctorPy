The following example looks the same as our previous RE, but omits the 'r' in front of the RE string. \b \b 'r' >>> p = re. compile('\bclass\b') >>> print(p. search('no class at all')) None >>> print(p. search('\b' + 'class' + '\b')) <re. Match object; span=(0, 7), match='\x08class\x08'> Second, inside a character class, where there’s no use for this assertion, \b represents the backspace character, for compatibility with Python’s string literals. \b \B Another zero-width assertion, this is the opposite of \b, only matching when the current position is not at a word boundary. \b ### Grouping¶ Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a ':', like this: ':' From: author@example. com User-Agent: Thunderbird 1. 5. 0. 9 (X11/20061227) MIME-Version: 1. 0 To: editor@example. com This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value. Groups are marked by the '(', ')' metacharacters. '(' and ')' have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a quantifier, such as , +,. , or {m,n}. For example, (ab) will match zero or more repetitions of ab. '(' ')' '(' ')' * +. {m,n} (ab)* ab >>> p = re. compile('(ab)*') >>> print(p. match('ababababab'). span()) (0, 10) Groups indicated with '(', ')' also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to group(), start(), end(), and span(). Groups are numbered starting with 0.