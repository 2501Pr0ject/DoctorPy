Roughly equivalent to: def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i]. = n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) Added in version 3. 1. Make an iterator that returns elements from data where the corresponding element in selectors is true. Stops when either the data or selectors iterables have been exhausted. Roughly equivalent to: def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F return (datum for datum, selector in zip(data, selectors) if selector) Added in version 3. 1. Make an iterator that returns evenly spaced values beginning with start. Can be used with map() to generate consecutive data points or with zip() to add sequence numbers. Roughly equivalent to: map() zip() def count(start=0, step=1): # count(10) → 10 11 12 13 14. # count(2. 5, 0. 5) → 2. 5 3. 0 3. 5. n = start while True: yield n n += step When counting with floating-point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: (start + step * i for i in count()). (start + step * i for i in count()) Changed in version 3. 1: Added step argument and allowed non-integer arguments. Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to: def cycle(iterable): # cycle('ABCD') → A B C D A B C D A B C D. saved = [] for element in iterable: yield element saved. append(element) while saved: for element in saved: yield element This itertool may require significant auxiliary storage (depending on the length of the iterable).