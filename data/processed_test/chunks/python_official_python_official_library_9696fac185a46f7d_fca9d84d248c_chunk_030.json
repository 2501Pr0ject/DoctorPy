{
  "chunk_id": "python_official_python_official_library_9696fac185a46f7d_fca9d84d248c_chunk_030",
  "original_doc_id": "python_official_python_official_library_9696fac185a46f7d_fca9d84d248c",
  "content": "\" # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF iterators = [iter(iterable)] * n match incomplete: case 'fill': return zip_longest(*iterators, fillvalue=fillvalue) case 'strict': return zip(*iterators, strict=True) case 'ignore': return zip(*iterators) case _: raise ValueError('Expected fill, strict, or ignore') def roundrobin(*iterables): \"Visit input iterables in a cycle until each is exhausted. \" # roundrobin('ABC', 'D', 'EF') → A D E B F C # Algorithm credited to George Sakkis iterators = map(iter, iterables) for num_active in range(len(iterables), 0, -1): iterators = cycle(islice(iterators, num_active)) yield from map(next, iterators) def subslices(seq): \"Return all contiguous non-empty subslices of a sequence. \" # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D slices = starmap(slice, combinations(range(len(seq) + 1), 2)) return map(getitem, repeat(seq), slices) def iter_index(iterable, value, start=0, stop=None): \"Return indices where a value occurs in a sequence or iterable. \" # iter_index('AABCADEAF', 'A') → 0 1 4 7 seq_index = getattr(iterable, 'index', None) if seq_index is None: iterator = islice(iterable, start, stop) for i, element in enumerate(iterator, start): if element is value or element == value: yield i else: stop = len(iterable) if stop is None else stop i = start with suppress(ValueError): while True: yield (i := seq_index(value, i, stop)) i += 1 def iter_except(function, exception, first=None): \"Convert a call-until-exception interface to an iterator interface. \" # iter_except(d. popitem, KeyError) → non-blocking dictionary iterator with suppress(exception): if first is not None: yield first() while True: yield function() def multinomial(*counts): \"Number of distinct arrangements of a multiset. \" # Counter('abracadabra').",
  "title": "itertools — Functions creating iterators for efficient looping.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 30,
  "start_char": 48441,
  "end_char": 50346,
  "token_count": 501,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_9696fac185a46f7d.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:02.119476"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_9696fac185a46f7d_fca9d84d248c_chunk_030.txt"
}