Order comparisons (‘<’, ‘<=’, ‘>=’, ‘>’) raise TypeError. To illustrate dictionary creation and equality, the following examples all return a dictionary equal to {"one": 1, "two": 2, "three": 3}: (key, value) TypeError {"one": 1, "two": 2, "three": 3} >>> a = dict(one=1, two=2, three=3) >>> b = {'one': 1, 'two': 2, 'three': 3} >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3])) >>> d = dict([('two', 2), ('one', 1), ('three', 3)]) >>> e = dict({'three': 3, 'one': 1, 'two': 2}) >>> f = dict({'one': 1, 'three': 3}, two=2) >>> a == b == c == d == e == f True Providing keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used. Dictionaries preserve insertion order. Note that updating a key does not affect the order. Keys added after deletion are inserted at the end. >>> d = {"one": 1, "two": 2, "three": 3, "four": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(d) ['one', 'two', 'three', 'four'] >>> list(d. values()) [1, 2, 3, 4] >>> d["one"] = 42 >>> d {'one': 42, 'two': 2, 'three': 3, 'four': 4} >>> del d["two"] >>> d["two"] = None >>> d {'one': 42, 'three': 3, 'four': 4, 'two': None} Changed in version 3. 7: Dictionary order is guaranteed to be insertion order. This behavior was an implementation detail of CPython from 3. 6. These are the operations that dictionaries support (and therefore, custom mapping types should support too): Return a list of all the keys used in the dictionary d. Return the number of items in the dictionary d.