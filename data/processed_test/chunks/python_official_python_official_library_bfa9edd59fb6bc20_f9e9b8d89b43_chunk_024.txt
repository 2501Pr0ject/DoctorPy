range for The arguments to the range constructor must be integers (either built-in int or any object that implements the index() special method). If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. If step is zero, ValueError is raised. int __index__() 1 0 ValueError For a positive step, the contents of a range r are determined by the formula r[i] = start + stepi where i >= 0 and r[i] < stop. r r[i] = start + step*i i >= 0 r[i] < stop For a negative step, the contents of the range are still determined by the formula r[i] = start + stepi, but the constraints are i >= 0 and r[i] > stop. r[i] = start + step*i i >= 0 r[i] > stop A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. r[0] Ranges containing absolute values larger than sys. maxsize are permitted but some features (such as len()) may raise OverflowError. sys. maxsize len() OverflowError Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern).