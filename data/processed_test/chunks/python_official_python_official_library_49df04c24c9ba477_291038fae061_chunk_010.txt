combinations_with_replacement(iterable, r)). pool = tuple(iterable) n = len(pool) indices = sorted(random. choices(range(n), k=r)) return tuple(pool[i] for i in indices) The default random() returns multiples of 2⁻⁵³ in the range 0. 0 ≤ x < 1. 0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, 0. 05954861408025609 isn’t an integer multiple of 2⁻⁵³. random() 0. 05954861408025609 The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. from random import Random from math import ldexp class FullRandom(Random): def random(self): mantissa = 0x10_0000_0000_0000 | self. getrandbits(52) exponent = -53 x = 0 while not x: x = self. getrandbits(32) exponent += x. bit_length() - 32 return ldexp(mantissa, exponent) All real valued distributions in the class will use the new method: >>> fr = FullRandom() >>> fr. random() 0. 05954861408025609 >>> fr. expovariate(0. 25) 8. 87925541791544 The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0. 0 ≤ x < 1. 0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to math. ulp(0. 0). ) math. ulp(0. 0) See also Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by random().