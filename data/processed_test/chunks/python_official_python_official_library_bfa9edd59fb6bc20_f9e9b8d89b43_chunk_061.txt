memoryview bytes bytearray A memoryview has the notion of an element, which is the atomic memory unit handled by the originating object. For many simple types such as bytes and bytearray, an element is a single byte, but other types such as array. array may have bigger elements. memoryview bytes bytearray array. array len(view) is equal to the length of tolist, which is the nested list representation of the view. If view. ndim = 1, this is equal to the number of elements in the view. len(view) tolist view. ndim = 1 Changed in version 3. 12: If view. ndim == 0, len(view) now raises TypeError instead of returning 1. view. ndim == 0 len(view) TypeError The itemsize attribute will give you the number of bytes in a single element. itemsize A memoryview supports slicing and indexing to expose its data. One-dimensional slicing will result in a subview: memoryview >>> v = memoryview(b'abcefg') >>> v[1] 98 >>> v[-1] 103 >>> v[1:4] <memory at 0x7f3ddc9f4350> >>> bytes(v[1:4]) b'bce' If format is one of the native format specifiers from the struct module, indexing with an integer or a tuple of integers is also supported and returns a single element with the correct type. One-dimensional memoryviews can be indexed with an integer or a one-integer tuple. Multi-dimensional memoryviews can be indexed with tuples of exactly ndim integers where ndim is the number of dimensions. Zero-dimensional memoryviews can be indexed with the empty tuple. format struct Here is an example with a non-byte format: >>> import array >>> a = array. array('l', [-11111111, 22222222, -33333333, 44444444]) >>> m = memoryview(a) >>> m[0] -11111111 >>> m[-1] 44444444 >>> m[::2]. tolist() [-11111111, -33333333] If the underlying object is writable, the memoryview supports one-dimensional slice assignment. Resizing is not allowed: >>> data = bytearray(b'abcefg') >>> v = memoryview(data) >>> v.