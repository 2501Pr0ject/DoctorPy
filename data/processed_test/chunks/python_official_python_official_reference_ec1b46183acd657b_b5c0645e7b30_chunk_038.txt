NoDefault def overly_generic SimpleTypeVar, TypeVarWithDefault = int, TypeVarWithBound: int, TypeVarWithConstraints: (str, bytes), *SimpleTypeVarTuple = (int, float), **SimpleParamSpec = (str, bytearray), :. def funcT:. annotation-def TYPE_PARAMS_OF_func(): T = typing. TypeVar("T") def func(arg: T):. func. __type_params__ = (T,) return func func = TYPE_PARAMS_OF_func() annotation-def typing typing. TypeVar @decorator def funcT: int, *Ts, **P:. TypeVar DEFAULT_OF_arg = some_default annotation-def TYPE_PARAMS_OF_func(): annotation-def BOUND_OF_T(): return int # In reality, BOUND_OF_T() is evaluated only on demand. T = typing. TypeVar("T", bound=BOUND_OF_T()) Ts = typing. TypeVarTuple("Ts") P = typing. ParamSpec("P") def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):. func. __type_params__ = (T, Ts, P) return func func = decorator(TYPE_PARAMS_OF_func()) DEFAULT_OF_arg class Bag[T]:. annotation-def TYPE_PARAMS_OF_Bag(): T = typing. TypeVar("T") class Bag(typing. Generic[T]): __type_params__ = (T,). return Bag Bag = TYPE_PARAMS_OF_Bag() annotation-def TYPE_PARAMS_OF_Bag typing. Generic @decorator class Bag(Base[T], arg=T):. annotation-def TYPE_PARAMS_OF_Bag(): T = typing. TypeVar("T") class Bag(Base[T], typing. Generic[T], arg=T): __type_params__ = (T,). return Bag Bag = decorator(TYPE_PARAMS_OF_Bag()) type type ListOrSet[T] = list[T] | set[T] annotation-def TYPE_PARAMS_OF_ListOrSet(): T = typing. TypeVar("T") annotation-def VALUE_OF_ListOrSet(): return list[T] | set[T] # In reality, the value is lazily evaluated return typing. TypeAliasType("ListOrSet", VALUE_OF_ListOrSet(), type_params=(T,)) ListOrSet = TYPE_PARAMS_OF_ListOrSet() annotation-def TYPE_PARAMS_OF_ListOrSet if while for try except except* else finally with match async for async with.