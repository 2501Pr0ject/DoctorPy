joinpath(PurePosixPath('passwd')) PurePosixPath('/etc/passwd') >>> PurePosixPath('/etc'). joinpath('init. d', 'apache2') PurePosixPath('/etc/init. d/apache2') >>> PureWindowsPath('c:'). joinpath('/Program Files') PureWindowsPath('c:/Program Files') Match this path against the provided glob-style pattern. Return True if matching is successful, False otherwise. For example: True False >>> PurePath('a/b. py'). full_match('a/*. py') True >>> PurePath('a/b. py'). full_match('*. py') False >>> PurePath('/a/b/c. py'). full_match('/a/**') True >>> PurePath('/a/b/c. py'). full_match('**/*. py') True See also Pattern language documentation. As with other methods, case-sensitivity follows platform defaults: >>> PurePosixPath('b. py'). full_match('*. PY') False >>> PureWindowsPath('b. py'). full_match('*. PY') True Set case_sensitive to True or False to override this behaviour. True False Added in version 3. 13. Match this path against the provided non-recursive glob-style pattern. Return True if matching is successful, False otherwise. True False This method is similar to full_match(), but empty patterns aren’t allowed (ValueError is raised), the recursive wildcard “” isn’t supported (it acts like non-recursive “*”), and if a relative pattern is provided, then matching is done from the right: full_match() ValueError ** * >>> PurePath('a/b. py'). match('*. py') True >>> PurePath('/a/b/c. py'). match('b/*. py') True >>> PurePath('/a/b/c. py'). match('a/*. py') False Changed in version 3. 12: The pattern parameter accepts a path-like object. Changed in version 3. 12: The case_sensitive parameter was added. Compute a version of this path relative to the path represented by other. If it’s impossible, ValueError is raised: ValueError >>> p = PurePosixPath('/etc/passwd') >>> p. relative_to('/') PurePosixPath('etc/passwd') >>> p. relative_to('/etc') PurePosixPath('passwd') >>> p.