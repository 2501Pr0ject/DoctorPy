0 ≤ r ≤ n r > n def combinations(iterable, r): # combinations('ABCD', 2) → AB AC AD BC BD CD # combinations(range(4), 3) → 012 013 023 123 pool = tuple(iterable) n = len(pool) if r > n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i]. = i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) product() (n + r - 1). / r. / (n - 1). n > 0 def combinations_with_replacement(iterable, r): # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC pool = tuple(iterable) n = len(pool) if not n and r: return indices = [0] * r yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i]. = n - 1: break else: return indices[i:] = [indices[i] + 1] * (r - i) yield tuple(pool[i] for i in indices) def compress(data, selectors): # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F return (datum for datum, selector in zip(data, selectors) if selector) map() zip() def count(start=0, step=1): # count(10) → 10 11 12 13 14. # count(2. 5, 0. 5) → 2. 5 3. 0 3. 5. n = start while True: yield n n += step (start + step * i for i in count()) def cycle(iterable): # cycle('ABCD') → A B C D A B C D A B C D. saved = [] for element in iterable: yield element saved.