This enables decorator stacking, pickling, and the creation of unit tests for each variant independently: register() pickling >>> @fun. register(float). @fun. register(Decimal). def fun_num(arg, verbose=False):. if verbose:. print("Half of your number:", end=" "). print(arg / 2). >>> fun_num is fun False When called, the generic function dispatches on the type of the first argument: >>> fun("Hello, world. ") Hello, world. >>> fun("test. ", verbose=True) Let me just say, test. >>> fun(42, verbose=True) Strength in numbers, eh. 42 >>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True) Enumerate this: 0 spam 1 spam 2 eggs 3 spam >>> fun(None) Nothing. >>> fun(1. 23) 0. 615 Where there is no registered implementation for a specific type, its method resolution order is used to find a more generic implementation. The original function decorated with @singledispatch is registered for the base object type, which means it is used if no better implementation is found. @singledispatch object If an implementation is registered to an abstract base class, virtual subclasses of the base class will be dispatched to that implementation: >>> from collections. abc import Mapping >>> @fun. register. def _(arg: Mapping, verbose=False):. if verbose:. print("Keys & Values"). for key, value in arg. items():. print(key, "=>", value). >>> fun({"a": "b"}) a => b To check which implementation the generic function will choose for a given type, use the dispatch() attribute: dispatch() >>> fun. dispatch(float) <function fun_num at 0x1035a2840> >>> fun. dispatch(dict) # note: default implementation <function fun at 0x103fe0000> To access all registered implementations, use the read-only registry attribute: registry >>> fun. registry. keys() dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>, <class 'decimal. Decimal'>, <class 'list'>, <class 'float'>]) >>> fun. registry[float] <function fun_num at 0x1035a2840> >>> fun.