ValueError The RFC does not explicitly forbid JSON strings which contain byte sequences that don’t correspond to valid Unicode characters (e. g. unpaired UTF-16 surrogates), but it does note that they may cause interoperability problems. By default, this module accepts and outputs (when present in the original str) code points for such sequences. str ### Infinite and NaN Number Values¶ The RFC does not permit the representation of infinite or NaN number values. Despite that, by default, this module accepts and outputs Infinity, -Infinity, and NaN as if they were valid JSON number literal values: Infinity -Infinity NaN >>> # Neither of these calls raises an exception, but the results are not valid JSON >>> json. dumps(float('-inf')) '-Infinity' >>> json. dumps(float('nan')) 'NaN' >>> # Same when deserializing >>> json. loads('-Infinity') -inf >>> json. loads('NaN') nan In the serializer, the allow_nan parameter can be used to alter this behavior. In the deserializer, the parse_constant parameter can be used to alter this behavior. ### Repeated Names Within an Object¶ The RFC specifies that the names within a JSON object should be unique, but does not mandate how repeated names in JSON objects should be handled. By default, this module does not raise an exception; instead, it ignores all but the last name-value pair for a given name: >>> weird_json = '{"x": 1, "x": 2, "x": 3}' >>> json. loads(weird_json) {'x': 3} The object_pairs_hook parameter can be used to alter this behavior. ### Top-level Non-Object, Non-Array Values¶ The old version of JSON specified by the obsolete RFC 4627 required that the top-level value of a JSON text must be either a JSON object or array (Python dict or list), and could not be a JSON null, boolean, number, or string value. RFC 7159 removed that restriction, and this module does not and has never implemented that restriction in either its serializer or its deserializer. dict list Regardless, for maximum interoperability, you may wish to voluntarily adhere to the restriction yourself.