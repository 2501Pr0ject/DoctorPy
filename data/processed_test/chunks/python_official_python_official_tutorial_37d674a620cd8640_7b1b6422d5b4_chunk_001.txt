count('tangerine') 0 >>> fruits. index('banana') 3 >>> fruits. index('banana', 4) # Find next banana starting at position 4 6 >>> fruits. reverse() >>> fruits ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange'] >>> fruits. append('grape') >>> fruits ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape'] >>> fruits. sort() >>> fruits ['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear'] >>> fruits. pop() 'pear' You might have noticed that methods like insert, remove or sort that only modify the list have no return value printed – they return the default None. [1] This is a design principle for all mutable data structures in Python. insert remove sort None Another thing you might notice is that not all data can be sorted or compared. For instance, [None, 'hello', 10] doesn’t sort because integers can’t be compared to strings and None can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, 3+4j < 5+7j isn’t a valid comparison. [None, 'hello', 10] None 3+4j < 5+7j ### 5. 1. 1. Using Lists as Stacks¶ The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use append(). To retrieve an item from the top of the stack, use pop() without an explicit index. For example: append() pop() >>> stack = [3, 4, 5] >>> stack. append(6) >>> stack. append(7) >>> stack [3, 4, 5, 6, 7] >>> stack. pop() 7 >>> stack [3, 4, 5, 6] >>> stack. pop() 6 >>> stack. pop() 5 >>> stack [3, 4] ### 5. 1. 2.