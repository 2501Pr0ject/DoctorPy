sub('-', 'abxd') '-a-b--d-' If replacement is a string, any backslash escapes in it are processed. That is, \n is converted to a single newline character, \r is converted to a carriage return, and so forth. Unknown escapes such as \& are left alone. Backreferences, such as \6, are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string. \n \r \& \6 This example matches the word section followed by a string enclosed in {, }, and changes section to subsection: section { } section subsection >>> p = re. compile('section{ ( [^}]* ) }', re. VERBOSE) >>> p. sub(r'subsection{\1}','section{First} section{second}') 'subsection{First} subsection{second}' There’s also a syntax for referring to named groups as defined by the (. P. ) syntax. \g will use the substring matched by the group named name, and \g uses the corresponding group number. \g<2> is therefore equivalent to \2, but isn’t ambiguous in a replacement string such as \g<2>0. (\20 would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character '0'. ) The following substitutions are all equivalent, but use all three variations of the replacement string. (. P<name>. ) \g<name> name \g<number> \g<2> \2 \g<2>0 \20 '0' >>> p = re. compile('section{ (. P<name> [^}]* ) }', re. VERBOSE) >>> p. sub(r'subsection{\1}','section{First}') 'subsection{First}' >>> p. sub(r'subsection{\g<1>}','section{First}') 'subsection{First}' >>> p. sub(r'subsection{\g<name>}','section{First}') 'subsection{First}' replacement can also be a function, which gives you even more control. If replacement is a function, the function is called for every non-overlapping occurrence of pattern. On each call, the function is passed a match object argument for the match and can use this information to compute the desired replacement string and return it.