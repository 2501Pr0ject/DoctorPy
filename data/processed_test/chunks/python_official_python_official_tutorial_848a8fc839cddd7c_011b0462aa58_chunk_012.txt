Here’s an example that fails due to this restriction: actor parrot parrot(voltage=1000) >>> def function(a):. pass. >>> function(0, a=0) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: function() got multiple values for argument 'a' When a final formal parameter of the form name is present, it receives a dictionary (see Mapping Types — dict) containing all keyword arguments except for those corresponding to a formal parameter. This may be combined with a formal parameter of the form name (described in the next subsection) which receives a tuple containing the positional arguments beyond the formal parameter list. (name must occur before name. ) For example, if we define a function like this: **name *name *name **name def cheeseshop(kind, *arguments, **keywords): print("-- Do you have any", kind, ". ") print("-- I'm sorry, we're all out of", kind) for arg in arguments: print(arg) print("-" * 40) for kw in keywords: print(kw, ":", keywords[kw]) It could be called like this: cheeseshop("Limburger", "It's very runny, sir. ", "It's really very, VERY runny, sir. ", shopkeeper="Michael Palin", client="John Cleese", sketch="Cheese Shop Sketch") and of course it would print: -- Do you have any Limburger. -- I'm sorry, we're all out of Limburger It's very runny, sir. It's really very, VERY runny, sir. ---------------------------------------- shopkeeper : Michael Palin client : John Cleese sketch : Cheese Shop Sketch Note that the order in which the keyword arguments are printed is guaranteed to match the order in which they were provided in the function call. ### 4. 9. 3. Special parameters¶ By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and performance, it makes sense to restrict the way arguments can be passed so that a developer need only look at the function definition to determine if items are passed by position, by position or keyword, or by keyword.