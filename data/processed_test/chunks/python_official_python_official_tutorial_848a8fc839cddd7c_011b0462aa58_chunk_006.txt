An important exception is that they donâ€™t match iterators or strings. Sequence patterns support extended unpacking: [x, y, rest] and (x, y, rest) work similar to unpacking assignments. The name after * may also be , so (x, y, _) matches a sequence of at least two items without binding the remaining items. Sequence patterns support extended unpacking: [x, y, rest] and (x, y, rest) work similar to unpacking assignments. The name after * may also be _, so (x, y, ) matches a sequence of at least two items without binding the remaining items. [x, y, *rest] (x, y, *rest) * _ (x, y, *_) Mapping patterns: {"bandwidth": b, "latency": l} captures the "bandwidth" and "latency" values from a dictionary. Unlike sequence patterns, extra keys are ignored. An unpacking like rest is also supported. (But would be redundant, so it is not allowed. ) Mapping patterns: {"bandwidth": b, "latency": l} captures the "bandwidth" and "latency" values from a dictionary. Unlike sequence patterns, extra keys are ignored. An unpacking like rest is also supported. (But would be redundant, so it is not allowed. ) {"bandwidth": b, "latency": l} "bandwidth" "latency" **rest **_ Subpatterns may be captured using the as keyword: case (Point(x1, y1), Point(x2, y2) as p2):. will capture the second element of the input as p2 (as long as the input is a sequence of two points) Subpatterns may be captured using the as keyword: as case (Point(x1, y1), Point(x2, y2) as p2):. will capture the second element of the input as p2 (as long as the input is a sequence of two points) p2 Most literals are compared by equality, however the singletons True, False and None are compared by identity. Most literals are compared by equality, however the singletons True, False and None are compared by identity. True False None Patterns may use named constants.