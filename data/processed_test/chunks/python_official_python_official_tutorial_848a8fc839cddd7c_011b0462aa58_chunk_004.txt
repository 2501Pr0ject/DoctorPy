Only the first pattern that matches gets executed and it can also extract components (sequence elements or object attributes) from the value into variables. match The simplest form compares a subject value against one or more literals: def http_error(status): match status: case 400: return "Bad request" case 404: return "Not found" case 418: return "I'm a teapot" case _: return "Something's wrong with the internet" Note the last block: the “variable name” _ acts as a wildcard and never fails to match. If no case matches, none of the branches is executed. _ You can combine several literals in a single pattern using | (“or”): | case 401 | 403 | 404: return "Not allowed" Patterns can look like unpacking assignments, and can be used to bind variables: # point is an (x, y) tuple match point: case (0, 0): print("Origin") case (0, y): print(f"Y={y}") case (x, 0): print(f"X={x}") case (x, y): print(f"X={x}, Y={y}") case _: raise ValueError("Not a point") Study that one carefully. The first pattern has two literals, and can be thought of as an extension of the literal pattern shown above. But the next two patterns combine a literal and a variable, and the variable binds a value from the subject (point). The fourth pattern captures two values, which makes it conceptually similar to the unpacking assignment (x, y) = point. point (x, y) = point If you are using classes to structure your data you can use the class name followed by an argument list resembling a constructor, but with the ability to capture attributes into variables: class Point: def __init__(self, x, y): self. x = x self. y = y def where_is(point): match point: case Point(x=0, y=0): print("Origin") case Point(x=0, y=y): print(f"Y={y}") case Point(x=x, y=0): print(f"X={x}") case Point(): print("Somewhere else") case _: print("Not a point") You can use positional parameters with some builtin classes that provide an ordering for their attributes (e. g. dataclasses).