__floor__ Integral (x * y) + z float (x * y) + z fma(0, inf, nan) fma(inf, 0, nan) math. fma x / y fmod(x, y) x % y fmod(x, y) x - n*y abs(y) x % y fmod(-1e-100, 1e100) -1e-100 -1e-100 % 1e100 1e100-1e-100 1e100 fmod() x % y modf() x - n*y n x / y x / y n r = remainder(x, y) abs(r) <= 0. 5 * abs(y) remainder(x, math. inf) remainder(x, 0) remainder(math. inf, x) ValueError trunc() floor() ceil() x. __trunc__ Integral ceil() floor() modf() abs(x) >= 2**52 copysign(1. 0, -0. 0) (m, e) x == m * 2**e (0. 0, 0) 0. 5 <= abs(m) < 1 frexp() True False abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol) rel_tol=0. 05 1e-09 1. 0 0. 0 x 0. 0 isclose(x, 0) abs(x) <= rel_tol * abs(x) False x 1. 0 NaN inf -inf NaN NaN inf -inf True False 0. 0 True False True False x * (2**i) frexp() math. nextafter(x, math. inf) math. nextafter(x, -math. inf) math. nextafter(x, 0. 0) math. nextafter(x, math. copysign(math. inf, x)) math. ulp() ulp(-x) sys. float_info. min x - ulp(x) x + ulp(x) math. nextafter() sys. float_info. epsilon math. e ** x pow(math. e, x) exp(x) - 1 expm1() >>> from math import exp, expm1 >>> exp(1e-5) - 1 # gives result accurate to 11 places 1.