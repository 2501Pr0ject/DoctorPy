The Python UTF-8 Mode ignores the locale encoding and forces the usage of the UTF-8 encoding: Use UTF-8 as the filesystem encoding. Use UTF-8 as the filesystem encoding. sys. getfilesystemencoding() returns 'utf-8'. sys. getfilesystemencoding() returns 'utf-8'. sys. getfilesystemencoding() 'utf-8' locale. getpreferredencoding() returns 'utf-8' (the do_setlocale argument has no effect). locale. getpreferredencoding() returns 'utf-8' (the do_setlocale argument has no effect). locale. getpreferredencoding() 'utf-8' sys. stdin, sys. stdout, and sys. stderr all use UTF-8 as their text encoding, with the surrogateescape error handler being enabled for sys. stdin and sys. stdout (sys. stderr continues to use backslashreplace as it does in the default locale-aware mode) sys. stdin, sys. stdout, and sys. stderr all use UTF-8 as their text encoding, with the surrogateescape error handler being enabled for sys. stdin and sys. stdout (sys. stderr continues to use backslashreplace as it does in the default locale-aware mode) sys. stdin sys. stdout sys. stderr surrogateescape sys. stdin sys. stdout sys. stderr backslashreplace On Unix, os. device_encoding() returns 'utf-8' rather than the device encoding. On Unix, os. device_encoding() returns 'utf-8' rather than the device encoding. os. device_encoding() 'utf-8' Note that the standard stream settings in UTF-8 mode can be overridden by PYTHONIOENCODING (just as they can be in the default locale-aware mode). PYTHONIOENCODING As a consequence of the changes in those lower level APIs, other higher level APIs also exhibit different default behaviours: Command line arguments, environment variables and filenames are decoded to text using the UTF-8 encoding. Command line arguments, environment variables and filenames are decoded to text using the UTF-8 encoding. os. fsdecode() and os. fsencode() use the UTF-8 encoding. os. fsdecode() and os. fsencode() use the UTF-8 encoding. os. fsdecode() os. fsencode() open(), io. open(), and codecs. open() use the UTF-8 encoding by default.