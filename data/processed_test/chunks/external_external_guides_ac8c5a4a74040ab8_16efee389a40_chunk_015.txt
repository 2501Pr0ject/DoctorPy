Group 0 is always present; it’s the whole RE, so match object methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match. '(' ')' group() start() end() span() >>> p = re. compile('(a)b') >>> m = p. match('ab') >>> m. group() 'ab' >>> m. group(0) 'ab' Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right. >>> p = re. compile('(a(b)c)d') >>> m = p. match('abcd') >>> m. group(0) 'abcd' >>> m. group(1) 'abc' >>> m. group(2) 'b' group() can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups. group() >>> m. group(2,1,2) ('b', 'abc', 'b') The groups() method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are. groups() >>> m. groups() ('abc', 'b') Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, \1 will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE. \1 For example, the following RE detects doubled words in a string. >>> p = re. compile(r'\b(\w+)\s+\1\b') >>> p. search('Paris in the the spring'). group() 'the the' Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re very useful when performing string substitutions. ### Non-capturing and Named Groups¶ Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself.