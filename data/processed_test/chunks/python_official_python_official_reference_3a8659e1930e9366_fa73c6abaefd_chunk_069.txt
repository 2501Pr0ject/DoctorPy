ABCMeta isinstance(instance, class) issubclass(subclass, class) isinstance() issubclass() __instancecheck__() __subclasscheck__() abc list[int] list int typing. Generic __class_getitem__() __class_getitem__() @classmethod __class_getitem__() __class_getitem__() typing. Generic __class_getitem__() __class_getitem__() __class_getitem__() __getitem__() __class_getitem__() __class_getitem__() obj[x] __getitem__() __class_getitem__() from inspect import isclass def subscribe(obj, x): """Return the result of the expression 'obj[x]'""" class_of_obj = type(obj) # If the class of obj defines __getitem__, # call class_of_obj. __getitem__(obj, x) if hasattr(class_of_obj, '__getitem__'): return class_of_obj. __getitem__(obj, x) # Else, if obj is a class and defines __class_getitem__, # call obj. __class_getitem__(x) elif isclass(obj) and hasattr(obj, '__class_getitem__'): return obj. __class_getitem__(x) # Else, raise an exception else: raise TypeError( f"'{class_of_obj. __name__}' object is not subscriptable" ) type type __getitem__() list[int] dict[str, float] tuple[str, bytes] __class_getitem__() >>> # list has class "type" as its metaclass, like most classes: >>> type(list) <class 'type'> >>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes) True >>> # "list[int]" calls "list. __class_getitem__(int)" >>> list[int] list[int] >>> # list. __class_getitem__ returns a GenericAlias object: >>> type(list[int]) <class 'types. GenericAlias'> __getitem__() enum >>> from enum import Enum >>> class Menu(Enum):. """A breakfast menu""". SPAM = 'spam'. BACON = 'bacon'. >>> # Enum classes have a custom metaclass: >>> type(Menu) <class 'enum. EnumMeta'> >>> # EnumMeta defines __getitem__, >>> # so __class_getitem__ is not called, >>> # and the result is not a GenericAlias object: >>> Menu['SPAM'] <Menu.