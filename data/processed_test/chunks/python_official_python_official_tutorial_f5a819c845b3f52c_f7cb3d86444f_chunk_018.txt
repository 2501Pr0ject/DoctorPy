append(trick) >>> d = Dog('Fido') >>> e = Dog('Buddy') >>> d. add_trick('roll over') >>> e. add_trick('play dead') >>> d. tricks ['roll over'] >>> e. tricks ['play dead'] >>> class Warehouse:. purpose = 'storage'. region = 'west'. >>> w1 = Warehouse() >>> print(w1. purpose, w1. region) storage west >>> w2 = Warehouse() >>> w2. region = 'east' >>> print(w2. purpose, w2. region) storage east self self # Function defined outside the class def f1(self, x, y): return min(x, x+y) class C: f = f1 def g(self): return 'hello world' h = g f g h C C h g self class Bag: def __init__(self): self. data = [] def add(self, x): self. data. append(x) def addtwice(self, x): self. add(x) self. add(x) object. __class__ class DerivedClassName(BaseClassName): <statement-1>. <statement-N> BaseClassName class DerivedClassName(modname. BaseClassName): DerivedClassName() virtual BaseClassName. methodname(self, arguments) BaseClassName isinstance() isinstance(obj, int) True obj. __class__ int int issubclass() issubclass(bool, int) True bool int issubclass(float, int) False float int class DerivedClassName(Base1, Base2, Base3): <statement-1>. <statement-N> DerivedClassName Base1 Base1 Base2 super() object object _spam __spam _classname__spam classname class Mapping: def __init__(self, iterable): self. items_list = [] self. __update(iterable) def update(self, iterable): for item in iterable: self. items_list. append(item) __update = update # private copy of original update() method class MappingSubclass(Mapping): def update(self, keys, values): # provides new signature for update() # but does not break __init__() for item in zip(keys, values): self. items_list.