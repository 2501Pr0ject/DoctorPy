bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str. join() at the end or else write to an io. StringIO instance and retrieve its value when complete if concatenating str objects, you can build a list and use str. join() at the end or else write to an io. StringIO instance and retrieve its value when complete str str. join() io. StringIO if concatenating bytes objects, you can similarly use bytes. join() or io. BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating bytes objects, you can similarly use bytes. join() or io. BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism bytes bytes. join() io. BytesIO bytearray bytearray if concatenating tuple objects, extend a list instead if concatenating tuple objects, extend a list instead tuple list for other types, investigate the relevant class documentation for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. Some sequence types (such as range) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition. range index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j]. index(x), only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. index raises ValueError when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].