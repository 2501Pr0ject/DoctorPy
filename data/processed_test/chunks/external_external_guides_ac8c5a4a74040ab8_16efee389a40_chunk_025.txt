search() ### Greedy versus Non-Greedy¶ When repeating a regular expression, as in a, the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of. a*. * >>> s = '<html><head><title>Title</title>' >>> len(s) 32 >>> print(re. match('<. *>', s). span()) (0, 32) >>> print(re. match('<. *>', s). group()) <html><head><title>Title</title> The RE matches the '<' in '', and the. consumes the rest of the string. There’s still more left in the RE, though, and the > can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the >. The final match extends from the '<' in '' to the '>' in '', which isn’t what you want. '<' '<html>'. * > > '<' '<html>' '>' '</title>' In this case, the solution is to use the non-greedy quantifiers. , +. ,. , or {m,n}. , which match as little text as possible. In the above example, the '>' is tried immediately after the first '<' matches, and when it fails, the engine advances a character at a time, retrying the '>' at every step. This produces just the right result: *. +. {m,n}. '>' '<' '>' >>> print(re. match('<. *. >', s). group()) <html> (Note that parsing HTML or XML with regular expressions is painful. Quick-and-dirty patterns will handle common cases, but HTML and XML have special cases that will break the obvious regular expression; by the time you’ve written a regular expression that handles all of the possible cases, the patterns will be very complicated. Use an HTML or XML parser module for such tasks. ) ### Using re. VERBOSE¶ By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand. For such REs, specifying the re.