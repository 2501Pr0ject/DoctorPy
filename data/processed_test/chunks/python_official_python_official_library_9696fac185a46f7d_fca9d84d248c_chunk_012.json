{
  "chunk_id": "python_official_python_official_library_9696fac185a46f7d_fca9d84d248c_chunk_012",
  "original_doc_id": "python_official_python_official_library_9696fac185a46f7d_fca9d84d248c",
  "content": "Roughly equivalent to: def takewhile(predicate, iterable): # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4 for x in iterable: if not predicate(x): break yield x Note, the element that first fails the predicate condition is consumed from the input iterator and there is no way to access it. This could be an issue if an application wants to further consume the input iterator after takewhile has been run to exhaustion. To work around this problem, consider using more-itertools before_and_after() instead. Return n independent iterators from a single iterable. Roughly equivalent to: def tee(iterable, n=2): if n < 0: raise ValueError if n == 0: return () iterator = _tee(iterable) result = [iterator] for _ in range(n - 1): result. append(_tee(iterator)) return tuple(result) class _tee: def __init__(self, iterable): it = iter(iterable) if isinstance(it, _tee): self. iterator = it. iterator self. link = it. link else: self. iterator = it self. link = [None, None] def __iter__(self): return self def __next__(self): link = self. link if link[1] is None: link[0] = next(self. iterator) link[1] = [None, None] value, self. link = link return value When the input iterable is already a tee iterator object, all members of the return tuple are constructed as if they had been produced by the upstream tee() call. This “flattening step” allows nested tee() calls to share the same underlying data chain and to have a single update step rather than a chain of calls. tee() tee() The flattening property makes tee iterators efficiently peekable: def lookahead(tee_iterator): \"Return the next value without moving the input forward\" [forked_iterator] = tee(tee_iterator, 1) return next(forked_iterator) >>> iterator = iter('abcdef') >>> [iterator] = tee(iterator, 1) # Make the input peekable >>> next(iterator) # Move the iterator forward 'a' >>> lookahead(iterator) # Check next value 'b' >>> next(iterator) # Continue moving forward 'b' tee iterators are not threadsafe.",
  "title": "itertools — Functions creating iterators for efficient looping.13.5",
  "section": "python_official",
  "subsection": "library",
  "chunk_index": 12,
  "start_char": 20241,
  "end_char": 22208,
  "token_count": 489,
  "metadata": {
    "original_file": "data/raw/documentation_test/python_official/python_official_library_9696fac185a46f7d.md",
    "chunk_method": "paragraph_based",
    "overlap_chars": 100,
    "processing_date": "2025-06-11T23:57:02.104273"
  },
  "file_path": "data/processed_test/chunks/python_official_python_official_library_9696fac185a46f7d_fca9d84d248c_chunk_012.txt"
}