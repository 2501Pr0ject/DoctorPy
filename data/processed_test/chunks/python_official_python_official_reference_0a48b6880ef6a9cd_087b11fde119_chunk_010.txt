>>> generator = echo(1) >>> print(next(generator)) Execution starts when 'next()' is called for the first time. 1 >>> print(next(generator)) None >>> print(generator. send(2)) 2 >>> generator. throw(TypeError, "spam") TypeError('spam',) >>> generator. close() Don't forget to clean up when 'close()' is called. For examples using yield from, see PEP 380: Syntax for Delegating to a Subgenerator in “What’s New in Python. ” yield from #### 6. 2. 9. 3. Asynchronous generator functions¶ The presence of a yield expression in a function or method defined using async def further defines the function as an asynchronous generator function. async def When an asynchronous generator function is called, it returns an asynchronous iterator known as an asynchronous generator object. That object then controls the execution of the generator function. An asynchronous generator object is typically used in an async for statement in a coroutine function analogously to how a generator object would be used in a for statement. async for for Calling one of the asynchronous generator’s methods returns an awaitable object, and the execution starts when this object is awaited on. At that time, the execution proceeds to the first yield expression, where it is suspended again, returning the value of yield_list to the awaiting coroutine. As with a generator, suspension means that all local state is retained, including the current bindings of local variables, the instruction pointer, the internal evaluation stack, and the state of any exception handling. When the execution is resumed by awaiting on the next object returned by the asynchronous generator’s methods, the function can proceed exactly as if the yield expression were just another external call. The value of the yield expression after resuming depends on the method which resumed the execution. If anext() is used then the result is None. Otherwise, if asend() is used, then the result will be the value passed in to that method. yield_list __anext__() None asend() If an asynchronous generator happens to exit early by break, the caller task being cancelled, or other exceptions, the generator’s async cleanup code will run and possibly raise exceptions or access context variables in an unexpected context–perhaps after the lifetime of tasks it depends, or during the event loop shutdown when the async-generator garbage collection hook is called.